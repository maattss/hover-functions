schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# columns and relationships of "achievement"
type achievement {
  # An object relationship
  achievementTypeByAchievementType: achievement_type!
  achievement_type: achievement_type_enum!
  created_at: timestamptz
  description: String

  # An object relationship
  feed: feed
  id: Int!
  level: Int!
  name: String!
  rule(
    # JSON select path
    path: String
  ): json!

  # An array relationship
  user_achievements(
    # distinct select on columns
    distinct_on: [user_achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_achievement_order_by!]

    # filter the rows returned
    where: user_achievement_bool_exp
  ): [user_achievement!]!

  # An aggregated array relationship
  user_achievements_aggregate(
    # distinct select on columns
    distinct_on: [user_achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_achievement_order_by!]

    # filter the rows returned
    where: user_achievement_bool_exp
  ): user_achievement_aggregate!
}

# aggregated selection of "achievement"
type achievement_aggregate {
  aggregate: achievement_aggregate_fields
  nodes: [achievement!]!
}

# aggregate fields of "achievement"
type achievement_aggregate_fields {
  avg: achievement_avg_fields
  count(columns: [achievement_select_column!], distinct: Boolean): Int
  max: achievement_max_fields
  min: achievement_min_fields
  stddev: achievement_stddev_fields
  stddev_pop: achievement_stddev_pop_fields
  stddev_samp: achievement_stddev_samp_fields
  sum: achievement_sum_fields
  var_pop: achievement_var_pop_fields
  var_samp: achievement_var_samp_fields
  variance: achievement_variance_fields
}

# order by aggregate values of table "achievement"
input achievement_aggregate_order_by {
  avg: achievement_avg_order_by
  count: order_by
  max: achievement_max_order_by
  min: achievement_min_order_by
  stddev: achievement_stddev_order_by
  stddev_pop: achievement_stddev_pop_order_by
  stddev_samp: achievement_stddev_samp_order_by
  sum: achievement_sum_order_by
  var_pop: achievement_var_pop_order_by
  var_samp: achievement_var_samp_order_by
  variance: achievement_variance_order_by
}

# input type for inserting array relation for remote table "achievement"
input achievement_arr_rel_insert_input {
  data: [achievement_insert_input!]!
  on_conflict: achievement_on_conflict
}

# aggregate avg on columns
type achievement_avg_fields {
  id: Float
  level: Float
}

# order by avg() on columns of table "achievement"
input achievement_avg_order_by {
  id: order_by
  level: order_by
}

# Boolean expression to filter rows from the table "achievement". All fields are combined with a logical 'AND'.
input achievement_bool_exp {
  _and: [achievement_bool_exp]
  _not: achievement_bool_exp
  _or: [achievement_bool_exp]
  achievementTypeByAchievementType: achievement_type_bool_exp
  achievement_type: achievement_type_enum_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  feed: feed_bool_exp
  id: Int_comparison_exp
  level: Int_comparison_exp
  name: String_comparison_exp
  rule: json_comparison_exp
  user_achievements: user_achievement_bool_exp
}

# unique or primary key constraints on table "achievement"
enum achievement_constraint {
  # unique or primary key constraint
  Acheivement_pkey
}

# input type for incrementing integer column in table "achievement"
input achievement_inc_input {
  id: Int
  level: Int
}

# input type for inserting data into table "achievement"
input achievement_insert_input {
  achievementTypeByAchievementType: achievement_type_obj_rel_insert_input
  achievement_type: achievement_type_enum
  created_at: timestamptz
  description: String
  feed: feed_obj_rel_insert_input
  id: Int
  level: Int
  name: String
  rule: json
  user_achievements: user_achievement_arr_rel_insert_input
}

# aggregate max on columns
type achievement_max_fields {
  created_at: timestamptz
  description: String
  id: Int
  level: Int
  name: String
}

# order by max() on columns of table "achievement"
input achievement_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  level: order_by
  name: order_by
}

# aggregate min on columns
type achievement_min_fields {
  created_at: timestamptz
  description: String
  id: Int
  level: Int
  name: String
}

# order by min() on columns of table "achievement"
input achievement_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  level: order_by
  name: order_by
}

# response of any mutation on the table "achievement"
type achievement_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [achievement!]!
}

# input type for inserting object relation for remote table "achievement"
input achievement_obj_rel_insert_input {
  data: achievement_insert_input!
  on_conflict: achievement_on_conflict
}

# on conflict condition type for table "achievement"
input achievement_on_conflict {
  constraint: achievement_constraint!
  update_columns: [achievement_update_column!]!
  where: achievement_bool_exp
}

# ordering options when selecting data from "achievement"
input achievement_order_by {
  achievementTypeByAchievementType: achievement_type_order_by
  achievement_type: order_by
  created_at: order_by
  description: order_by
  feed: feed_order_by
  id: order_by
  level: order_by
  name: order_by
  rule: order_by
  user_achievements_aggregate: user_achievement_aggregate_order_by
}

# primary key columns input for table: "achievement"
input achievement_pk_columns_input {
  id: Int!
}

# select columns of table "achievement"
enum achievement_select_column {
  # column name
  achievement_type

  # column name
  created_at

  # column name
  description

  # column name
  id

  # column name
  level

  # column name
  name

  # column name
  rule
}

# input type for updating data in table "achievement"
input achievement_set_input {
  achievement_type: achievement_type_enum
  created_at: timestamptz
  description: String
  id: Int
  level: Int
  name: String
  rule: json
}

# aggregate stddev on columns
type achievement_stddev_fields {
  id: Float
  level: Float
}

# order by stddev() on columns of table "achievement"
input achievement_stddev_order_by {
  id: order_by
  level: order_by
}

# aggregate stddev_pop on columns
type achievement_stddev_pop_fields {
  id: Float
  level: Float
}

# order by stddev_pop() on columns of table "achievement"
input achievement_stddev_pop_order_by {
  id: order_by
  level: order_by
}

# aggregate stddev_samp on columns
type achievement_stddev_samp_fields {
  id: Float
  level: Float
}

# order by stddev_samp() on columns of table "achievement"
input achievement_stddev_samp_order_by {
  id: order_by
  level: order_by
}

# aggregate sum on columns
type achievement_sum_fields {
  id: Int
  level: Int
}

# order by sum() on columns of table "achievement"
input achievement_sum_order_by {
  id: order_by
  level: order_by
}

# columns and relationships of "achievement_type"
type achievement_type {
  # An array relationship
  achievements(
    # distinct select on columns
    distinct_on: [achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_order_by!]

    # filter the rows returned
    where: achievement_bool_exp
  ): [achievement!]!

  # An aggregated array relationship
  achievements_aggregate(
    # distinct select on columns
    distinct_on: [achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_order_by!]

    # filter the rows returned
    where: achievement_bool_exp
  ): achievement_aggregate!
  description: String
  name: String!
}

# aggregated selection of "achievement_type"
type achievement_type_aggregate {
  aggregate: achievement_type_aggregate_fields
  nodes: [achievement_type!]!
}

# aggregate fields of "achievement_type"
type achievement_type_aggregate_fields {
  count(columns: [achievement_type_select_column!], distinct: Boolean): Int
  max: achievement_type_max_fields
  min: achievement_type_min_fields
}

# order by aggregate values of table "achievement_type"
input achievement_type_aggregate_order_by {
  count: order_by
  max: achievement_type_max_order_by
  min: achievement_type_min_order_by
}

# input type for inserting array relation for remote table "achievement_type"
input achievement_type_arr_rel_insert_input {
  data: [achievement_type_insert_input!]!
  on_conflict: achievement_type_on_conflict
}

# Boolean expression to filter rows from the table "achievement_type". All fields are combined with a logical 'AND'.
input achievement_type_bool_exp {
  _and: [achievement_type_bool_exp]
  _not: achievement_type_bool_exp
  _or: [achievement_type_bool_exp]
  achievements: achievement_bool_exp
  description: String_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "achievement_type"
enum achievement_type_constraint {
  # unique or primary key constraint
  achievement_type_pkey
}

enum achievement_type_enum {
  # First activity on the app
  FIRST_ACTIVITY
  SCORE
  SCORE_IN_CATEGORY
}

# expression to compare columns of type achievement_type_enum. All fields are combined with logical 'AND'.
input achievement_type_enum_comparison_exp {
  _eq: achievement_type_enum
  _in: [achievement_type_enum!]
  _is_null: Boolean
  _neq: achievement_type_enum
  _nin: [achievement_type_enum!]
}

# input type for inserting data into table "achievement_type"
input achievement_type_insert_input {
  achievements: achievement_arr_rel_insert_input
  description: String
  name: String
}

# aggregate max on columns
type achievement_type_max_fields {
  description: String
  name: String
}

# order by max() on columns of table "achievement_type"
input achievement_type_max_order_by {
  description: order_by
  name: order_by
}

# aggregate min on columns
type achievement_type_min_fields {
  description: String
  name: String
}

# order by min() on columns of table "achievement_type"
input achievement_type_min_order_by {
  description: order_by
  name: order_by
}

# response of any mutation on the table "achievement_type"
type achievement_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [achievement_type!]!
}

# input type for inserting object relation for remote table "achievement_type"
input achievement_type_obj_rel_insert_input {
  data: achievement_type_insert_input!
  on_conflict: achievement_type_on_conflict
}

# on conflict condition type for table "achievement_type"
input achievement_type_on_conflict {
  constraint: achievement_type_constraint!
  update_columns: [achievement_type_update_column!]!
  where: achievement_type_bool_exp
}

# ordering options when selecting data from "achievement_type"
input achievement_type_order_by {
  achievements_aggregate: achievement_aggregate_order_by
  description: order_by
  name: order_by
}

# primary key columns input for table: "achievement_type"
input achievement_type_pk_columns_input {
  name: String!
}

# select columns of table "achievement_type"
enum achievement_type_select_column {
  # column name
  description

  # column name
  name
}

# input type for updating data in table "achievement_type"
input achievement_type_set_input {
  description: String
  name: String
}

# update columns of table "achievement_type"
enum achievement_type_update_column {
  # column name
  description

  # column name
  name
}

# update columns of table "achievement"
enum achievement_update_column {
  # column name
  achievement_type

  # column name
  created_at

  # column name
  description

  # column name
  id

  # column name
  level

  # column name
  name

  # column name
  rule
}

# aggregate var_pop on columns
type achievement_var_pop_fields {
  id: Float
  level: Float
}

# order by var_pop() on columns of table "achievement"
input achievement_var_pop_order_by {
  id: order_by
  level: order_by
}

# aggregate var_samp on columns
type achievement_var_samp_fields {
  id: Float
  level: Float
}

# order by var_samp() on columns of table "achievement"
input achievement_var_samp_order_by {
  id: order_by
  level: order_by
}

# aggregate variance on columns
type achievement_variance_fields {
  id: Float
  level: Float
}

# order by variance() on columns of table "achievement"
input achievement_variance_order_by {
  id: order_by
  level: order_by
}

# columns and relationships of "activities"
type activities {
  activity_id: Int!
  caption: String
  created_at: timestamptz
  duration: interval!

  # An object relationship
  feed: feed

  # An array relationship
  feeds(
    # distinct select on columns
    distinct_on: [feed_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_order_by!]

    # filter the rows returned
    where: feed_bool_exp
  ): [feed!]!

  # An aggregated array relationship
  feeds_aggregate(
    # distinct select on columns
    distinct_on: [feed_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_order_by!]

    # filter the rows returned
    where: feed_bool_exp
  ): feed_aggregate!

  # An object relationship
  geofence: geofences!
  geofence_id: Int!
  score: Int
  started_at: timestamptz

  # A computed field, executes function "stopped_at"
  stopped_at: timestamptz
  updated_at: timestamptz

  # An object relationship
  user: users!
  user_id: String!
}

# aggregated selection of "activities"
type activities_aggregate {
  aggregate: activities_aggregate_fields
  nodes: [activities!]!
}

# aggregate fields of "activities"
type activities_aggregate_fields {
  avg: activities_avg_fields
  count(columns: [activities_select_column!], distinct: Boolean): Int
  max: activities_max_fields
  min: activities_min_fields
  stddev: activities_stddev_fields
  stddev_pop: activities_stddev_pop_fields
  stddev_samp: activities_stddev_samp_fields
  sum: activities_sum_fields
  var_pop: activities_var_pop_fields
  var_samp: activities_var_samp_fields
  variance: activities_variance_fields
}

# order by aggregate values of table "activities"
input activities_aggregate_order_by {
  avg: activities_avg_order_by
  count: order_by
  max: activities_max_order_by
  min: activities_min_order_by
  stddev: activities_stddev_order_by
  stddev_pop: activities_stddev_pop_order_by
  stddev_samp: activities_stddev_samp_order_by
  sum: activities_sum_order_by
  var_pop: activities_var_pop_order_by
  var_samp: activities_var_samp_order_by
  variance: activities_variance_order_by
}

# input type for inserting array relation for remote table "activities"
input activities_arr_rel_insert_input {
  data: [activities_insert_input!]!
  on_conflict: activities_on_conflict
}

# aggregate avg on columns
type activities_avg_fields {
  activity_id: Float
  geofence_id: Float
  score: Float
}

# order by avg() on columns of table "activities"
input activities_avg_order_by {
  activity_id: order_by
  geofence_id: order_by
  score: order_by
}

# Boolean expression to filter rows from the table "activities". All fields are combined with a logical 'AND'.
input activities_bool_exp {
  _and: [activities_bool_exp]
  _not: activities_bool_exp
  _or: [activities_bool_exp]
  activity_id: Int_comparison_exp
  caption: String_comparison_exp
  created_at: timestamptz_comparison_exp
  duration: interval_comparison_exp
  feed: feed_bool_exp
  feeds: feed_bool_exp
  geofence: geofences_bool_exp
  geofence_id: Int_comparison_exp
  score: Int_comparison_exp
  started_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

# unique or primary key constraints on table "activities"
enum activities_constraint {
  # unique or primary key constraint
  Activity_pkey

  # unique or primary key constraint
  activities_activity_id_user_id_key

  # unique or primary key constraint
  activities_started_at_user_id_key
}

# input type for incrementing integer column in table "activities"
input activities_inc_input {
  activity_id: Int
  geofence_id: Int
  score: Int
}

# input type for inserting data into table "activities"
input activities_insert_input {
  activity_id: Int
  caption: String
  created_at: timestamptz
  duration: interval
  feed: feed_obj_rel_insert_input
  feeds: feed_arr_rel_insert_input
  geofence: geofences_obj_rel_insert_input
  geofence_id: Int
  score: Int
  started_at: timestamptz
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

# aggregate max on columns
type activities_max_fields {
  activity_id: Int
  caption: String
  created_at: timestamptz
  geofence_id: Int
  score: Int
  started_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

# order by max() on columns of table "activities"
input activities_max_order_by {
  activity_id: order_by
  caption: order_by
  created_at: order_by
  geofence_id: order_by
  score: order_by
  started_at: order_by
  updated_at: order_by
  user_id: order_by
}

# aggregate min on columns
type activities_min_fields {
  activity_id: Int
  caption: String
  created_at: timestamptz
  geofence_id: Int
  score: Int
  started_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

# order by min() on columns of table "activities"
input activities_min_order_by {
  activity_id: order_by
  caption: order_by
  created_at: order_by
  geofence_id: order_by
  score: order_by
  started_at: order_by
  updated_at: order_by
  user_id: order_by
}

# response of any mutation on the table "activities"
type activities_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [activities!]!
}

# input type for inserting object relation for remote table "activities"
input activities_obj_rel_insert_input {
  data: activities_insert_input!
  on_conflict: activities_on_conflict
}

# on conflict condition type for table "activities"
input activities_on_conflict {
  constraint: activities_constraint!
  update_columns: [activities_update_column!]!
  where: activities_bool_exp
}

# ordering options when selecting data from "activities"
input activities_order_by {
  activity_id: order_by
  caption: order_by
  created_at: order_by
  duration: order_by
  feed: feed_order_by
  feeds_aggregate: feed_aggregate_order_by
  geofence: geofences_order_by
  geofence_id: order_by
  score: order_by
  started_at: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

# primary key columns input for table: "activities"
input activities_pk_columns_input {
  activity_id: Int!
}

# select columns of table "activities"
enum activities_select_column {
  # column name
  activity_id

  # column name
  caption

  # column name
  created_at

  # column name
  duration

  # column name
  geofence_id

  # column name
  score

  # column name
  started_at

  # column name
  updated_at

  # column name
  user_id
}

# input type for updating data in table "activities"
input activities_set_input {
  activity_id: Int
  caption: String
  created_at: timestamptz
  duration: interval
  geofence_id: Int
  score: Int
  started_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

# aggregate stddev on columns
type activities_stddev_fields {
  activity_id: Float
  geofence_id: Float
  score: Float
}

# order by stddev() on columns of table "activities"
input activities_stddev_order_by {
  activity_id: order_by
  geofence_id: order_by
  score: order_by
}

# aggregate stddev_pop on columns
type activities_stddev_pop_fields {
  activity_id: Float
  geofence_id: Float
  score: Float
}

# order by stddev_pop() on columns of table "activities"
input activities_stddev_pop_order_by {
  activity_id: order_by
  geofence_id: order_by
  score: order_by
}

# aggregate stddev_samp on columns
type activities_stddev_samp_fields {
  activity_id: Float
  geofence_id: Float
  score: Float
}

# order by stddev_samp() on columns of table "activities"
input activities_stddev_samp_order_by {
  activity_id: order_by
  geofence_id: order_by
  score: order_by
}

# aggregate sum on columns
type activities_sum_fields {
  activity_id: Int
  geofence_id: Int
  score: Int
}

# order by sum() on columns of table "activities"
input activities_sum_order_by {
  activity_id: order_by
  geofence_id: order_by
  score: order_by
}

# update columns of table "activities"
enum activities_update_column {
  # column name
  activity_id

  # column name
  caption

  # column name
  created_at

  # column name
  duration

  # column name
  geofence_id

  # column name
  score

  # column name
  started_at

  # column name
  updated_at

  # column name
  user_id
}

# aggregate var_pop on columns
type activities_var_pop_fields {
  activity_id: Float
  geofence_id: Float
  score: Float
}

# order by var_pop() on columns of table "activities"
input activities_var_pop_order_by {
  activity_id: order_by
  geofence_id: order_by
  score: order_by
}

# aggregate var_samp on columns
type activities_var_samp_fields {
  activity_id: Float
  geofence_id: Float
  score: Float
}

# order by var_samp() on columns of table "activities"
input activities_var_samp_order_by {
  activity_id: order_by
  geofence_id: order_by
  score: order_by
}

# aggregate variance on columns
type activities_variance_fields {
  activity_id: Float
  geofence_id: Float
  score: Float
}

# order by variance() on columns of table "activities"
input activities_variance_order_by {
  activity_id: order_by
  geofence_id: order_by
  score: order_by
}

scalar bigint

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# columns and relationships of "categories"
type categories {
  description: String!
  name: String!
  points_per_minute: Int!
}

# aggregated selection of "categories"
type categories_aggregate {
  aggregate: categories_aggregate_fields
  nodes: [categories!]!
}

# aggregate fields of "categories"
type categories_aggregate_fields {
  avg: categories_avg_fields
  count(columns: [categories_select_column!], distinct: Boolean): Int
  max: categories_max_fields
  min: categories_min_fields
  stddev: categories_stddev_fields
  stddev_pop: categories_stddev_pop_fields
  stddev_samp: categories_stddev_samp_fields
  sum: categories_sum_fields
  var_pop: categories_var_pop_fields
  var_samp: categories_var_samp_fields
  variance: categories_variance_fields
}

# order by aggregate values of table "categories"
input categories_aggregate_order_by {
  avg: categories_avg_order_by
  count: order_by
  max: categories_max_order_by
  min: categories_min_order_by
  stddev: categories_stddev_order_by
  stddev_pop: categories_stddev_pop_order_by
  stddev_samp: categories_stddev_samp_order_by
  sum: categories_sum_order_by
  var_pop: categories_var_pop_order_by
  var_samp: categories_var_samp_order_by
  variance: categories_variance_order_by
}

# input type for inserting array relation for remote table "categories"
input categories_arr_rel_insert_input {
  data: [categories_insert_input!]!
  on_conflict: categories_on_conflict
}

# aggregate avg on columns
type categories_avg_fields {
  points_per_minute: Float
}

# order by avg() on columns of table "categories"
input categories_avg_order_by {
  points_per_minute: order_by
}

# Boolean expression to filter rows from the table "categories". All fields are combined with a logical 'AND'.
input categories_bool_exp {
  _and: [categories_bool_exp]
  _not: categories_bool_exp
  _or: [categories_bool_exp]
  description: String_comparison_exp
  name: String_comparison_exp
  points_per_minute: Int_comparison_exp
}

# unique or primary key constraints on table "categories"
enum categories_constraint {
  # unique or primary key constraint
  Category_name_key

  # unique or primary key constraint
  categories_pkey
}

# input type for incrementing integer column in table "categories"
input categories_inc_input {
  points_per_minute: Int
}

# input type for inserting data into table "categories"
input categories_insert_input {
  description: String
  name: String
  points_per_minute: Int
}

# aggregate max on columns
type categories_max_fields {
  description: String
  name: String
  points_per_minute: Int
}

# order by max() on columns of table "categories"
input categories_max_order_by {
  description: order_by
  name: order_by
  points_per_minute: order_by
}

# aggregate min on columns
type categories_min_fields {
  description: String
  name: String
  points_per_minute: Int
}

# order by min() on columns of table "categories"
input categories_min_order_by {
  description: order_by
  name: order_by
  points_per_minute: order_by
}

# response of any mutation on the table "categories"
type categories_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [categories!]!
}

# input type for inserting object relation for remote table "categories"
input categories_obj_rel_insert_input {
  data: categories_insert_input!
  on_conflict: categories_on_conflict
}

# on conflict condition type for table "categories"
input categories_on_conflict {
  constraint: categories_constraint!
  update_columns: [categories_update_column!]!
  where: categories_bool_exp
}

# ordering options when selecting data from "categories"
input categories_order_by {
  description: order_by
  name: order_by
  points_per_minute: order_by
}

# primary key columns input for table: "categories"
input categories_pk_columns_input {
  name: String!
}

# select columns of table "categories"
enum categories_select_column {
  # column name
  description

  # column name
  name

  # column name
  points_per_minute
}

# input type for updating data in table "categories"
input categories_set_input {
  description: String
  name: String
  points_per_minute: Int
}

# aggregate stddev on columns
type categories_stddev_fields {
  points_per_minute: Float
}

# order by stddev() on columns of table "categories"
input categories_stddev_order_by {
  points_per_minute: order_by
}

# aggregate stddev_pop on columns
type categories_stddev_pop_fields {
  points_per_minute: Float
}

# order by stddev_pop() on columns of table "categories"
input categories_stddev_pop_order_by {
  points_per_minute: order_by
}

# aggregate stddev_samp on columns
type categories_stddev_samp_fields {
  points_per_minute: Float
}

# order by stddev_samp() on columns of table "categories"
input categories_stddev_samp_order_by {
  points_per_minute: order_by
}

# aggregate sum on columns
type categories_sum_fields {
  points_per_minute: Int
}

# order by sum() on columns of table "categories"
input categories_sum_order_by {
  points_per_minute: order_by
}

# update columns of table "categories"
enum categories_update_column {
  # column name
  description

  # column name
  name

  # column name
  points_per_minute
}

# aggregate var_pop on columns
type categories_var_pop_fields {
  points_per_minute: Float
}

# order by var_pop() on columns of table "categories"
input categories_var_pop_order_by {
  points_per_minute: order_by
}

# aggregate var_samp on columns
type categories_var_samp_fields {
  points_per_minute: Float
}

# order by var_samp() on columns of table "categories"
input categories_var_samp_order_by {
  points_per_minute: order_by
}

# aggregate variance on columns
type categories_variance_fields {
  points_per_minute: Float
}

# order by variance() on columns of table "categories"
input categories_variance_order_by {
  points_per_minute: order_by
}

# columns and relationships of "challenge"
type challenge {
  # An object relationship
  challengeTypeByChallengeType: challenge_type!

  # An array relationship
  challenge_participants(
    # distinct select on columns
    distinct_on: [challenge_participant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_order_by!]

    # filter the rows returned
    where: challenge_participant_bool_exp
  ): [challenge_participant!]!

  # An aggregated array relationship
  challenge_participants_aggregate(
    # distinct select on columns
    distinct_on: [challenge_participant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_order_by!]

    # filter the rows returned
    where: challenge_participant_bool_exp
  ): challenge_participant_aggregate!

  # An object relationship
  challenge_state: challenge_state!
  challenge_type: challenge_type_enum!
  created_at: timestamptz!
  created_by: String!

  # An object relationship
  created_by_user: users!
  end_date: date!

  # An object relationship
  feed: feed
  id: Int!
  rules(
    # JSON select path
    path: String
  ): json!
  start_date: date!
  state: challenge_state_enum!

  # An object relationship
  winner: users
  winner_id: String
}

# aggregated selection of "challenge"
type challenge_aggregate {
  aggregate: challenge_aggregate_fields
  nodes: [challenge!]!
}

# aggregate fields of "challenge"
type challenge_aggregate_fields {
  avg: challenge_avg_fields
  count(columns: [challenge_select_column!], distinct: Boolean): Int
  max: challenge_max_fields
  min: challenge_min_fields
  stddev: challenge_stddev_fields
  stddev_pop: challenge_stddev_pop_fields
  stddev_samp: challenge_stddev_samp_fields
  sum: challenge_sum_fields
  var_pop: challenge_var_pop_fields
  var_samp: challenge_var_samp_fields
  variance: challenge_variance_fields
}

# order by aggregate values of table "challenge"
input challenge_aggregate_order_by {
  avg: challenge_avg_order_by
  count: order_by
  max: challenge_max_order_by
  min: challenge_min_order_by
  stddev: challenge_stddev_order_by
  stddev_pop: challenge_stddev_pop_order_by
  stddev_samp: challenge_stddev_samp_order_by
  sum: challenge_sum_order_by
  var_pop: challenge_var_pop_order_by
  var_samp: challenge_var_samp_order_by
  variance: challenge_variance_order_by
}

# input type for inserting array relation for remote table "challenge"
input challenge_arr_rel_insert_input {
  data: [challenge_insert_input!]!
  on_conflict: challenge_on_conflict
}

# aggregate avg on columns
type challenge_avg_fields {
  id: Float
}

# order by avg() on columns of table "challenge"
input challenge_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "challenge". All fields are combined with a logical 'AND'.
input challenge_bool_exp {
  _and: [challenge_bool_exp]
  _not: challenge_bool_exp
  _or: [challenge_bool_exp]
  challengeTypeByChallengeType: challenge_type_bool_exp
  challenge_participants: challenge_participant_bool_exp
  challenge_state: challenge_state_bool_exp
  challenge_type: challenge_type_enum_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: String_comparison_exp
  created_by_user: users_bool_exp
  end_date: date_comparison_exp
  feed: feed_bool_exp
  id: Int_comparison_exp
  rules: json_comparison_exp
  start_date: date_comparison_exp
  state: challenge_state_enum_comparison_exp
  winner: users_bool_exp
  winner_id: String_comparison_exp
}

# unique or primary key constraints on table "challenge"
enum challenge_constraint {
  # unique or primary key constraint
  challenge_id_winner_id_key

  # unique or primary key constraint
  user_challenge_pkey
}

# input type for incrementing integer column in table "challenge"
input challenge_inc_input {
  id: Int
}

# input type for inserting data into table "challenge"
input challenge_insert_input {
  challengeTypeByChallengeType: challenge_type_obj_rel_insert_input
  challenge_participants: challenge_participant_arr_rel_insert_input
  challenge_state: challenge_state_obj_rel_insert_input
  challenge_type: challenge_type_enum
  created_at: timestamptz
  created_by: String
  created_by_user: users_obj_rel_insert_input
  end_date: date
  feed: feed_obj_rel_insert_input
  id: Int
  rules: json
  start_date: date
  state: challenge_state_enum
  winner: users_obj_rel_insert_input
  winner_id: String
}

# aggregate max on columns
type challenge_max_fields {
  created_at: timestamptz
  created_by: String
  end_date: date
  id: Int
  start_date: date
  winner_id: String
}

# order by max() on columns of table "challenge"
input challenge_max_order_by {
  created_at: order_by
  created_by: order_by
  end_date: order_by
  id: order_by
  start_date: order_by
  winner_id: order_by
}

# aggregate min on columns
type challenge_min_fields {
  created_at: timestamptz
  created_by: String
  end_date: date
  id: Int
  start_date: date
  winner_id: String
}

# order by min() on columns of table "challenge"
input challenge_min_order_by {
  created_at: order_by
  created_by: order_by
  end_date: order_by
  id: order_by
  start_date: order_by
  winner_id: order_by
}

# response of any mutation on the table "challenge"
type challenge_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [challenge!]!
}

# input type for inserting object relation for remote table "challenge"
input challenge_obj_rel_insert_input {
  data: challenge_insert_input!
  on_conflict: challenge_on_conflict
}

# on conflict condition type for table "challenge"
input challenge_on_conflict {
  constraint: challenge_constraint!
  update_columns: [challenge_update_column!]!
  where: challenge_bool_exp
}

# ordering options when selecting data from "challenge"
input challenge_order_by {
  challengeTypeByChallengeType: challenge_type_order_by
  challenge_participants_aggregate: challenge_participant_aggregate_order_by
  challenge_state: challenge_state_order_by
  challenge_type: order_by
  created_at: order_by
  created_by: order_by
  created_by_user: users_order_by
  end_date: order_by
  feed: feed_order_by
  id: order_by
  rules: order_by
  start_date: order_by
  state: order_by
  winner: users_order_by
  winner_id: order_by
}

# columns and relationships of "challenge_participant"
type challenge_participant {
  # An object relationship
  challenge: challenge!
  challenge_id: Int!

  # An object relationship
  challenge_participant_state: challenge_participant_state!
  progress: float8
  state: challenge_participant_state_enum!

  # An object relationship
  user: users!
  user_id: String!
}

# aggregated selection of "challenge_participant"
type challenge_participant_aggregate {
  aggregate: challenge_participant_aggregate_fields
  nodes: [challenge_participant!]!
}

# aggregate fields of "challenge_participant"
type challenge_participant_aggregate_fields {
  avg: challenge_participant_avg_fields
  count(columns: [challenge_participant_select_column!], distinct: Boolean): Int
  max: challenge_participant_max_fields
  min: challenge_participant_min_fields
  stddev: challenge_participant_stddev_fields
  stddev_pop: challenge_participant_stddev_pop_fields
  stddev_samp: challenge_participant_stddev_samp_fields
  sum: challenge_participant_sum_fields
  var_pop: challenge_participant_var_pop_fields
  var_samp: challenge_participant_var_samp_fields
  variance: challenge_participant_variance_fields
}

# order by aggregate values of table "challenge_participant"
input challenge_participant_aggregate_order_by {
  avg: challenge_participant_avg_order_by
  count: order_by
  max: challenge_participant_max_order_by
  min: challenge_participant_min_order_by
  stddev: challenge_participant_stddev_order_by
  stddev_pop: challenge_participant_stddev_pop_order_by
  stddev_samp: challenge_participant_stddev_samp_order_by
  sum: challenge_participant_sum_order_by
  var_pop: challenge_participant_var_pop_order_by
  var_samp: challenge_participant_var_samp_order_by
  variance: challenge_participant_variance_order_by
}

# input type for inserting array relation for remote table "challenge_participant"
input challenge_participant_arr_rel_insert_input {
  data: [challenge_participant_insert_input!]!
  on_conflict: challenge_participant_on_conflict
}

# aggregate avg on columns
type challenge_participant_avg_fields {
  challenge_id: Float
  progress: Float
}

# order by avg() on columns of table "challenge_participant"
input challenge_participant_avg_order_by {
  challenge_id: order_by
  progress: order_by
}

# Boolean expression to filter rows from the table "challenge_participant". All fields are combined with a logical 'AND'.
input challenge_participant_bool_exp {
  _and: [challenge_participant_bool_exp]
  _not: challenge_participant_bool_exp
  _or: [challenge_participant_bool_exp]
  challenge: challenge_bool_exp
  challenge_id: Int_comparison_exp
  challenge_participant_state: challenge_participant_state_bool_exp
  progress: float8_comparison_exp
  state: challenge_participant_state_enum_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

# unique or primary key constraints on table "challenge_participant"
enum challenge_participant_constraint {
  # unique or primary key constraint
  challenge_participants_pkey
}

# input type for incrementing integer column in table "challenge_participant"
input challenge_participant_inc_input {
  challenge_id: Int
  progress: float8
}

# input type for inserting data into table "challenge_participant"
input challenge_participant_insert_input {
  challenge: challenge_obj_rel_insert_input
  challenge_id: Int
  challenge_participant_state: challenge_participant_state_obj_rel_insert_input
  progress: float8
  state: challenge_participant_state_enum
  user: users_obj_rel_insert_input
  user_id: String
}

# aggregate max on columns
type challenge_participant_max_fields {
  challenge_id: Int
  progress: float8
  user_id: String
}

# order by max() on columns of table "challenge_participant"
input challenge_participant_max_order_by {
  challenge_id: order_by
  progress: order_by
  user_id: order_by
}

# aggregate min on columns
type challenge_participant_min_fields {
  challenge_id: Int
  progress: float8
  user_id: String
}

# order by min() on columns of table "challenge_participant"
input challenge_participant_min_order_by {
  challenge_id: order_by
  progress: order_by
  user_id: order_by
}

# response of any mutation on the table "challenge_participant"
type challenge_participant_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [challenge_participant!]!
}

# input type for inserting object relation for remote table "challenge_participant"
input challenge_participant_obj_rel_insert_input {
  data: challenge_participant_insert_input!
  on_conflict: challenge_participant_on_conflict
}

# on conflict condition type for table "challenge_participant"
input challenge_participant_on_conflict {
  constraint: challenge_participant_constraint!
  update_columns: [challenge_participant_update_column!]!
  where: challenge_participant_bool_exp
}

# ordering options when selecting data from "challenge_participant"
input challenge_participant_order_by {
  challenge: challenge_order_by
  challenge_id: order_by
  challenge_participant_state: challenge_participant_state_order_by
  progress: order_by
  state: order_by
  user: users_order_by
  user_id: order_by
}

# primary key columns input for table: "challenge_participant"
input challenge_participant_pk_columns_input {
  challenge_id: Int!
  user_id: String!
}

# select columns of table "challenge_participant"
enum challenge_participant_select_column {
  # column name
  challenge_id

  # column name
  progress

  # column name
  state

  # column name
  user_id
}

# input type for updating data in table "challenge_participant"
input challenge_participant_set_input {
  challenge_id: Int
  progress: float8
  state: challenge_participant_state_enum
  user_id: String
}

# columns and relationships of "challenge_participant_state"
type challenge_participant_state {
  # An array relationship
  challenge_participants(
    # distinct select on columns
    distinct_on: [challenge_participant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_order_by!]

    # filter the rows returned
    where: challenge_participant_bool_exp
  ): [challenge_participant!]!

  # An aggregated array relationship
  challenge_participants_aggregate(
    # distinct select on columns
    distinct_on: [challenge_participant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_order_by!]

    # filter the rows returned
    where: challenge_participant_bool_exp
  ): challenge_participant_aggregate!
  state: String!
}

# aggregated selection of "challenge_participant_state"
type challenge_participant_state_aggregate {
  aggregate: challenge_participant_state_aggregate_fields
  nodes: [challenge_participant_state!]!
}

# aggregate fields of "challenge_participant_state"
type challenge_participant_state_aggregate_fields {
  count(columns: [challenge_participant_state_select_column!], distinct: Boolean): Int
  max: challenge_participant_state_max_fields
  min: challenge_participant_state_min_fields
}

# order by aggregate values of table "challenge_participant_state"
input challenge_participant_state_aggregate_order_by {
  count: order_by
  max: challenge_participant_state_max_order_by
  min: challenge_participant_state_min_order_by
}

# input type for inserting array relation for remote table "challenge_participant_state"
input challenge_participant_state_arr_rel_insert_input {
  data: [challenge_participant_state_insert_input!]!
  on_conflict: challenge_participant_state_on_conflict
}

# Boolean expression to filter rows from the table "challenge_participant_state".
# All fields are combined with a logical 'AND'.
input challenge_participant_state_bool_exp {
  _and: [challenge_participant_state_bool_exp]
  _not: challenge_participant_state_bool_exp
  _or: [challenge_participant_state_bool_exp]
  challenge_participants: challenge_participant_bool_exp
  state: String_comparison_exp
}

# unique or primary key constraints on table "challenge_participant_state"
enum challenge_participant_state_constraint {
  # unique or primary key constraint
  challenge_participant_state_pkey
}

enum challenge_participant_state_enum {
  ACCEPTED
  DECLINED
  PENDING
}

# expression to compare columns of type challenge_participant_state_enum. All fields are combined with logical 'AND'.
input challenge_participant_state_enum_comparison_exp {
  _eq: challenge_participant_state_enum
  _in: [challenge_participant_state_enum!]
  _is_null: Boolean
  _neq: challenge_participant_state_enum
  _nin: [challenge_participant_state_enum!]
}

# input type for inserting data into table "challenge_participant_state"
input challenge_participant_state_insert_input {
  challenge_participants: challenge_participant_arr_rel_insert_input
  state: String
}

# aggregate max on columns
type challenge_participant_state_max_fields {
  state: String
}

# order by max() on columns of table "challenge_participant_state"
input challenge_participant_state_max_order_by {
  state: order_by
}

# aggregate min on columns
type challenge_participant_state_min_fields {
  state: String
}

# order by min() on columns of table "challenge_participant_state"
input challenge_participant_state_min_order_by {
  state: order_by
}

# response of any mutation on the table "challenge_participant_state"
type challenge_participant_state_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [challenge_participant_state!]!
}

# input type for inserting object relation for remote table "challenge_participant_state"
input challenge_participant_state_obj_rel_insert_input {
  data: challenge_participant_state_insert_input!
  on_conflict: challenge_participant_state_on_conflict
}

# on conflict condition type for table "challenge_participant_state"
input challenge_participant_state_on_conflict {
  constraint: challenge_participant_state_constraint!
  update_columns: [challenge_participant_state_update_column!]!
  where: challenge_participant_state_bool_exp
}

# ordering options when selecting data from "challenge_participant_state"
input challenge_participant_state_order_by {
  challenge_participants_aggregate: challenge_participant_aggregate_order_by
  state: order_by
}

# primary key columns input for table: "challenge_participant_state"
input challenge_participant_state_pk_columns_input {
  state: String!
}

# select columns of table "challenge_participant_state"
enum challenge_participant_state_select_column {
  # column name
  state
}

# input type for updating data in table "challenge_participant_state"
input challenge_participant_state_set_input {
  state: String
}

# update columns of table "challenge_participant_state"
enum challenge_participant_state_update_column {
  # column name
  state
}

# aggregate stddev on columns
type challenge_participant_stddev_fields {
  challenge_id: Float
  progress: Float
}

# order by stddev() on columns of table "challenge_participant"
input challenge_participant_stddev_order_by {
  challenge_id: order_by
  progress: order_by
}

# aggregate stddev_pop on columns
type challenge_participant_stddev_pop_fields {
  challenge_id: Float
  progress: Float
}

# order by stddev_pop() on columns of table "challenge_participant"
input challenge_participant_stddev_pop_order_by {
  challenge_id: order_by
  progress: order_by
}

# aggregate stddev_samp on columns
type challenge_participant_stddev_samp_fields {
  challenge_id: Float
  progress: Float
}

# order by stddev_samp() on columns of table "challenge_participant"
input challenge_participant_stddev_samp_order_by {
  challenge_id: order_by
  progress: order_by
}

# aggregate sum on columns
type challenge_participant_sum_fields {
  challenge_id: Int
  progress: float8
}

# order by sum() on columns of table "challenge_participant"
input challenge_participant_sum_order_by {
  challenge_id: order_by
  progress: order_by
}

# update columns of table "challenge_participant"
enum challenge_participant_update_column {
  # column name
  challenge_id

  # column name
  progress

  # column name
  state

  # column name
  user_id
}

# aggregate var_pop on columns
type challenge_participant_var_pop_fields {
  challenge_id: Float
  progress: Float
}

# order by var_pop() on columns of table "challenge_participant"
input challenge_participant_var_pop_order_by {
  challenge_id: order_by
  progress: order_by
}

# aggregate var_samp on columns
type challenge_participant_var_samp_fields {
  challenge_id: Float
  progress: Float
}

# order by var_samp() on columns of table "challenge_participant"
input challenge_participant_var_samp_order_by {
  challenge_id: order_by
  progress: order_by
}

# aggregate variance on columns
type challenge_participant_variance_fields {
  challenge_id: Float
  progress: Float
}

# order by variance() on columns of table "challenge_participant"
input challenge_participant_variance_order_by {
  challenge_id: order_by
  progress: order_by
}

# primary key columns input for table: "challenge"
input challenge_pk_columns_input {
  id: Int!
}

# select columns of table "challenge"
enum challenge_select_column {
  # column name
  challenge_type

  # column name
  created_at

  # column name
  created_by

  # column name
  end_date

  # column name
  id

  # column name
  rules

  # column name
  start_date

  # column name
  state

  # column name
  winner_id
}

# input type for updating data in table "challenge"
input challenge_set_input {
  challenge_type: challenge_type_enum
  created_at: timestamptz
  created_by: String
  end_date: date
  id: Int
  rules: json
  start_date: date
  state: challenge_state_enum
  winner_id: String
}

# columns and relationships of "challenge_state"
type challenge_state {
  # An array relationship
  challenges(
    # distinct select on columns
    distinct_on: [challenge_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_order_by!]

    # filter the rows returned
    where: challenge_bool_exp
  ): [challenge!]!

  # An aggregated array relationship
  challenges_aggregate(
    # distinct select on columns
    distinct_on: [challenge_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_order_by!]

    # filter the rows returned
    where: challenge_bool_exp
  ): challenge_aggregate!
  state: String!
}

# aggregated selection of "challenge_state"
type challenge_state_aggregate {
  aggregate: challenge_state_aggregate_fields
  nodes: [challenge_state!]!
}

# aggregate fields of "challenge_state"
type challenge_state_aggregate_fields {
  count(columns: [challenge_state_select_column!], distinct: Boolean): Int
  max: challenge_state_max_fields
  min: challenge_state_min_fields
}

# order by aggregate values of table "challenge_state"
input challenge_state_aggregate_order_by {
  count: order_by
  max: challenge_state_max_order_by
  min: challenge_state_min_order_by
}

# input type for inserting array relation for remote table "challenge_state"
input challenge_state_arr_rel_insert_input {
  data: [challenge_state_insert_input!]!
  on_conflict: challenge_state_on_conflict
}

# Boolean expression to filter rows from the table "challenge_state". All fields are combined with a logical 'AND'.
input challenge_state_bool_exp {
  _and: [challenge_state_bool_exp]
  _not: challenge_state_bool_exp
  _or: [challenge_state_bool_exp]
  challenges: challenge_bool_exp
  state: String_comparison_exp
}

# unique or primary key constraints on table "challenge_state"
enum challenge_state_constraint {
  # unique or primary key constraint
  challenge_state_pkey
}

enum challenge_state_enum {
  ACTIVE
  CLOSED
  FINISHED
}

# expression to compare columns of type challenge_state_enum. All fields are combined with logical 'AND'.
input challenge_state_enum_comparison_exp {
  _eq: challenge_state_enum
  _in: [challenge_state_enum!]
  _is_null: Boolean
  _neq: challenge_state_enum
  _nin: [challenge_state_enum!]
}

# input type for inserting data into table "challenge_state"
input challenge_state_insert_input {
  challenges: challenge_arr_rel_insert_input
  state: String
}

# aggregate max on columns
type challenge_state_max_fields {
  state: String
}

# order by max() on columns of table "challenge_state"
input challenge_state_max_order_by {
  state: order_by
}

# aggregate min on columns
type challenge_state_min_fields {
  state: String
}

# order by min() on columns of table "challenge_state"
input challenge_state_min_order_by {
  state: order_by
}

# response of any mutation on the table "challenge_state"
type challenge_state_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [challenge_state!]!
}

# input type for inserting object relation for remote table "challenge_state"
input challenge_state_obj_rel_insert_input {
  data: challenge_state_insert_input!
  on_conflict: challenge_state_on_conflict
}

# on conflict condition type for table "challenge_state"
input challenge_state_on_conflict {
  constraint: challenge_state_constraint!
  update_columns: [challenge_state_update_column!]!
  where: challenge_state_bool_exp
}

# ordering options when selecting data from "challenge_state"
input challenge_state_order_by {
  challenges_aggregate: challenge_aggregate_order_by
  state: order_by
}

# primary key columns input for table: "challenge_state"
input challenge_state_pk_columns_input {
  state: String!
}

# select columns of table "challenge_state"
enum challenge_state_select_column {
  # column name
  state
}

# input type for updating data in table "challenge_state"
input challenge_state_set_input {
  state: String
}

# update columns of table "challenge_state"
enum challenge_state_update_column {
  # column name
  state
}

# aggregate stddev on columns
type challenge_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "challenge"
input challenge_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type challenge_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "challenge"
input challenge_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type challenge_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "challenge"
input challenge_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type challenge_sum_fields {
  id: Int
}

# order by sum() on columns of table "challenge"
input challenge_sum_order_by {
  id: order_by
}

# columns and relationships of "challenge_type"
type challenge_type {
  # An array relationship
  challenges(
    # distinct select on columns
    distinct_on: [challenge_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_order_by!]

    # filter the rows returned
    where: challenge_bool_exp
  ): [challenge!]!

  # An aggregated array relationship
  challenges_aggregate(
    # distinct select on columns
    distinct_on: [challenge_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_order_by!]

    # filter the rows returned
    where: challenge_bool_exp
  ): challenge_aggregate!
  description: String
  name: String!
}

# aggregated selection of "challenge_type"
type challenge_type_aggregate {
  aggregate: challenge_type_aggregate_fields
  nodes: [challenge_type!]!
}

# aggregate fields of "challenge_type"
type challenge_type_aggregate_fields {
  count(columns: [challenge_type_select_column!], distinct: Boolean): Int
  max: challenge_type_max_fields
  min: challenge_type_min_fields
}

# order by aggregate values of table "challenge_type"
input challenge_type_aggregate_order_by {
  count: order_by
  max: challenge_type_max_order_by
  min: challenge_type_min_order_by
}

# input type for inserting array relation for remote table "challenge_type"
input challenge_type_arr_rel_insert_input {
  data: [challenge_type_insert_input!]!
  on_conflict: challenge_type_on_conflict
}

# Boolean expression to filter rows from the table "challenge_type". All fields are combined with a logical 'AND'.
input challenge_type_bool_exp {
  _and: [challenge_type_bool_exp]
  _not: challenge_type_bool_exp
  _or: [challenge_type_bool_exp]
  challenges: challenge_bool_exp
  description: String_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "challenge_type"
enum challenge_type_constraint {
  # unique or primary key constraint
  challenge_type_description_key

  # unique or primary key constraint
  challenge_type_pkey
}

enum challenge_type_enum {
  # Score challenge
  SCORE

  # Score in specific category challenge
  SCORE_CATEGORY

  # Time challenge
  TIME

  # Time in specific category challenge
  TIME_CATEGORY
}

# expression to compare columns of type challenge_type_enum. All fields are combined with logical 'AND'.
input challenge_type_enum_comparison_exp {
  _eq: challenge_type_enum
  _in: [challenge_type_enum!]
  _is_null: Boolean
  _neq: challenge_type_enum
  _nin: [challenge_type_enum!]
}

# input type for inserting data into table "challenge_type"
input challenge_type_insert_input {
  challenges: challenge_arr_rel_insert_input
  description: String
  name: String
}

# aggregate max on columns
type challenge_type_max_fields {
  description: String
  name: String
}

# order by max() on columns of table "challenge_type"
input challenge_type_max_order_by {
  description: order_by
  name: order_by
}

# aggregate min on columns
type challenge_type_min_fields {
  description: String
  name: String
}

# order by min() on columns of table "challenge_type"
input challenge_type_min_order_by {
  description: order_by
  name: order_by
}

# response of any mutation on the table "challenge_type"
type challenge_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [challenge_type!]!
}

# input type for inserting object relation for remote table "challenge_type"
input challenge_type_obj_rel_insert_input {
  data: challenge_type_insert_input!
  on_conflict: challenge_type_on_conflict
}

# on conflict condition type for table "challenge_type"
input challenge_type_on_conflict {
  constraint: challenge_type_constraint!
  update_columns: [challenge_type_update_column!]!
  where: challenge_type_bool_exp
}

# ordering options when selecting data from "challenge_type"
input challenge_type_order_by {
  challenges_aggregate: challenge_aggregate_order_by
  description: order_by
  name: order_by
}

# primary key columns input for table: "challenge_type"
input challenge_type_pk_columns_input {
  name: String!
}

# select columns of table "challenge_type"
enum challenge_type_select_column {
  # column name
  description

  # column name
  name
}

# input type for updating data in table "challenge_type"
input challenge_type_set_input {
  description: String
  name: String
}

# update columns of table "challenge_type"
enum challenge_type_update_column {
  # column name
  description

  # column name
  name
}

# update columns of table "challenge"
enum challenge_update_column {
  # column name
  challenge_type

  # column name
  created_at

  # column name
  created_by

  # column name
  end_date

  # column name
  id

  # column name
  rules

  # column name
  start_date

  # column name
  state

  # column name
  winner_id
}

# aggregate var_pop on columns
type challenge_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "challenge"
input challenge_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type challenge_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "challenge"
input challenge_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type challenge_variance_fields {
  id: Float
}

# order by variance() on columns of table "challenge"
input challenge_variance_order_by {
  id: order_by
}

# columns and relationships of "comments"
type comments {
  # An object relationship
  activity: activities!
  activity_id: Int!
  comment_id: Int!
  content: String!
  created_at: timestamptz
  updated_at: timestamp

  # An object relationship
  user: users!
  user_id: String!
}

# aggregated selection of "comments"
type comments_aggregate {
  aggregate: comments_aggregate_fields
  nodes: [comments!]!
}

# aggregate fields of "comments"
type comments_aggregate_fields {
  avg: comments_avg_fields
  count(columns: [comments_select_column!], distinct: Boolean): Int
  max: comments_max_fields
  min: comments_min_fields
  stddev: comments_stddev_fields
  stddev_pop: comments_stddev_pop_fields
  stddev_samp: comments_stddev_samp_fields
  sum: comments_sum_fields
  var_pop: comments_var_pop_fields
  var_samp: comments_var_samp_fields
  variance: comments_variance_fields
}

# order by aggregate values of table "comments"
input comments_aggregate_order_by {
  avg: comments_avg_order_by
  count: order_by
  max: comments_max_order_by
  min: comments_min_order_by
  stddev: comments_stddev_order_by
  stddev_pop: comments_stddev_pop_order_by
  stddev_samp: comments_stddev_samp_order_by
  sum: comments_sum_order_by
  var_pop: comments_var_pop_order_by
  var_samp: comments_var_samp_order_by
  variance: comments_variance_order_by
}

# input type for inserting array relation for remote table "comments"
input comments_arr_rel_insert_input {
  data: [comments_insert_input!]!
  on_conflict: comments_on_conflict
}

# aggregate avg on columns
type comments_avg_fields {
  activity_id: Float
  comment_id: Float
}

# order by avg() on columns of table "comments"
input comments_avg_order_by {
  activity_id: order_by
  comment_id: order_by
}

# Boolean expression to filter rows from the table "comments". All fields are combined with a logical 'AND'.
input comments_bool_exp {
  _and: [comments_bool_exp]
  _not: comments_bool_exp
  _or: [comments_bool_exp]
  activity: activities_bool_exp
  activity_id: Int_comparison_exp
  comment_id: Int_comparison_exp
  content: String_comparison_exp
  created_at: timestamptz_comparison_exp
  updated_at: timestamp_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

# unique or primary key constraints on table "comments"
enum comments_constraint {
  # unique or primary key constraint
  Comments_pkey
}

# input type for incrementing integer column in table "comments"
input comments_inc_input {
  activity_id: Int
  comment_id: Int
}

# input type for inserting data into table "comments"
input comments_insert_input {
  activity: activities_obj_rel_insert_input
  activity_id: Int
  comment_id: Int
  content: String
  created_at: timestamptz
  updated_at: timestamp
  user: users_obj_rel_insert_input
  user_id: String
}

# aggregate max on columns
type comments_max_fields {
  activity_id: Int
  comment_id: Int
  content: String
  created_at: timestamptz
  updated_at: timestamp
  user_id: String
}

# order by max() on columns of table "comments"
input comments_max_order_by {
  activity_id: order_by
  comment_id: order_by
  content: order_by
  created_at: order_by
  updated_at: order_by
  user_id: order_by
}

# aggregate min on columns
type comments_min_fields {
  activity_id: Int
  comment_id: Int
  content: String
  created_at: timestamptz
  updated_at: timestamp
  user_id: String
}

# order by min() on columns of table "comments"
input comments_min_order_by {
  activity_id: order_by
  comment_id: order_by
  content: order_by
  created_at: order_by
  updated_at: order_by
  user_id: order_by
}

# response of any mutation on the table "comments"
type comments_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [comments!]!
}

# input type for inserting object relation for remote table "comments"
input comments_obj_rel_insert_input {
  data: comments_insert_input!
  on_conflict: comments_on_conflict
}

# on conflict condition type for table "comments"
input comments_on_conflict {
  constraint: comments_constraint!
  update_columns: [comments_update_column!]!
  where: comments_bool_exp
}

# ordering options when selecting data from "comments"
input comments_order_by {
  activity: activities_order_by
  activity_id: order_by
  comment_id: order_by
  content: order_by
  created_at: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

# primary key columns input for table: "comments"
input comments_pk_columns_input {
  comment_id: Int!
}

# select columns of table "comments"
enum comments_select_column {
  # column name
  activity_id

  # column name
  comment_id

  # column name
  content

  # column name
  created_at

  # column name
  updated_at

  # column name
  user_id
}

# input type for updating data in table "comments"
input comments_set_input {
  activity_id: Int
  comment_id: Int
  content: String
  created_at: timestamptz
  updated_at: timestamp
  user_id: String
}

# aggregate stddev on columns
type comments_stddev_fields {
  activity_id: Float
  comment_id: Float
}

# order by stddev() on columns of table "comments"
input comments_stddev_order_by {
  activity_id: order_by
  comment_id: order_by
}

# aggregate stddev_pop on columns
type comments_stddev_pop_fields {
  activity_id: Float
  comment_id: Float
}

# order by stddev_pop() on columns of table "comments"
input comments_stddev_pop_order_by {
  activity_id: order_by
  comment_id: order_by
}

# aggregate stddev_samp on columns
type comments_stddev_samp_fields {
  activity_id: Float
  comment_id: Float
}

# order by stddev_samp() on columns of table "comments"
input comments_stddev_samp_order_by {
  activity_id: order_by
  comment_id: order_by
}

# aggregate sum on columns
type comments_sum_fields {
  activity_id: Int
  comment_id: Int
}

# order by sum() on columns of table "comments"
input comments_sum_order_by {
  activity_id: order_by
  comment_id: order_by
}

# update columns of table "comments"
enum comments_update_column {
  # column name
  activity_id

  # column name
  comment_id

  # column name
  content

  # column name
  created_at

  # column name
  updated_at

  # column name
  user_id
}

# aggregate var_pop on columns
type comments_var_pop_fields {
  activity_id: Float
  comment_id: Float
}

# order by var_pop() on columns of table "comments"
input comments_var_pop_order_by {
  activity_id: order_by
  comment_id: order_by
}

# aggregate var_samp on columns
type comments_var_samp_fields {
  activity_id: Float
  comment_id: Float
}

# order by var_samp() on columns of table "comments"
input comments_var_samp_order_by {
  activity_id: order_by
  comment_id: order_by
}

# aggregate variance on columns
type comments_variance_fields {
  activity_id: Float
  comment_id: Float
}

# order by variance() on columns of table "comments"
input comments_variance_order_by {
  activity_id: order_by
  comment_id: order_by
}

scalar date

# expression to compare columns of type date. All fields are combined with logical 'AND'.
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

# columns and relationships of "feed"
type feed {
  achievement_id: Int

  # An object relationship
  activity: activities

  # An object relationship
  activityByActivityIdCreatedAtUserId: activities
  activity_id: Int

  # An object relationship
  challenge: challenge
  challenge_id: Int
  created_at: timestamptz

  # An object relationship
  feedTypeByFeedType: feed_type!
  feed_type: feed_type_enum!
  id: Int!

  # An object relationship
  user: users

  # An object relationship
  user_achievement: user_achievement
  user_id: String
}

# aggregated selection of "feed"
type feed_aggregate {
  aggregate: feed_aggregate_fields
  nodes: [feed!]!
}

# aggregate fields of "feed"
type feed_aggregate_fields {
  avg: feed_avg_fields
  count(columns: [feed_select_column!], distinct: Boolean): Int
  max: feed_max_fields
  min: feed_min_fields
  stddev: feed_stddev_fields
  stddev_pop: feed_stddev_pop_fields
  stddev_samp: feed_stddev_samp_fields
  sum: feed_sum_fields
  var_pop: feed_var_pop_fields
  var_samp: feed_var_samp_fields
  variance: feed_variance_fields
}

# order by aggregate values of table "feed"
input feed_aggregate_order_by {
  avg: feed_avg_order_by
  count: order_by
  max: feed_max_order_by
  min: feed_min_order_by
  stddev: feed_stddev_order_by
  stddev_pop: feed_stddev_pop_order_by
  stddev_samp: feed_stddev_samp_order_by
  sum: feed_sum_order_by
  var_pop: feed_var_pop_order_by
  var_samp: feed_var_samp_order_by
  variance: feed_variance_order_by
}

# input type for inserting array relation for remote table "feed"
input feed_arr_rel_insert_input {
  data: [feed_insert_input!]!
  on_conflict: feed_on_conflict
}

# aggregate avg on columns
type feed_avg_fields {
  achievement_id: Float
  activity_id: Float
  challenge_id: Float
  id: Float
}

# order by avg() on columns of table "feed"
input feed_avg_order_by {
  achievement_id: order_by
  activity_id: order_by
  challenge_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "feed". All fields are combined with a logical 'AND'.
input feed_bool_exp {
  _and: [feed_bool_exp]
  _not: feed_bool_exp
  _or: [feed_bool_exp]
  achievement_id: Int_comparison_exp
  activity: activities_bool_exp
  activityByActivityIdCreatedAtUserId: activities_bool_exp
  activity_id: Int_comparison_exp
  challenge: challenge_bool_exp
  challenge_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  feedTypeByFeedType: feed_type_bool_exp
  feed_type: feed_type_enum_comparison_exp
  id: Int_comparison_exp
  user: users_bool_exp
  user_achievement: user_achievement_bool_exp
  user_id: String_comparison_exp
}

# unique or primary key constraints on table "feed"
enum feed_constraint {
  # unique or primary key constraint
  feed_achievement_id_user_id_key

  # unique or primary key constraint
  feed_activity_id_user_id_key

  # unique or primary key constraint
  feed_challenge_id_user_id_key

  # unique or primary key constraint
  feed_pkey
}

# input type for incrementing integer column in table "feed"
input feed_inc_input {
  achievement_id: Int
  activity_id: Int
  challenge_id: Int
  id: Int
}

# input type for inserting data into table "feed"
input feed_insert_input {
  achievement_id: Int
  activity: activities_obj_rel_insert_input
  activityByActivityIdCreatedAtUserId: activities_obj_rel_insert_input
  activity_id: Int
  challenge: challenge_obj_rel_insert_input
  challenge_id: Int
  created_at: timestamptz
  feedTypeByFeedType: feed_type_obj_rel_insert_input
  feed_type: feed_type_enum
  id: Int
  user: users_obj_rel_insert_input
  user_achievement: user_achievement_obj_rel_insert_input
  user_id: String
}

# aggregate max on columns
type feed_max_fields {
  achievement_id: Int
  activity_id: Int
  challenge_id: Int
  created_at: timestamptz
  id: Int
  user_id: String
}

# order by max() on columns of table "feed"
input feed_max_order_by {
  achievement_id: order_by
  activity_id: order_by
  challenge_id: order_by
  created_at: order_by
  id: order_by
  user_id: order_by
}

# aggregate min on columns
type feed_min_fields {
  achievement_id: Int
  activity_id: Int
  challenge_id: Int
  created_at: timestamptz
  id: Int
  user_id: String
}

# order by min() on columns of table "feed"
input feed_min_order_by {
  achievement_id: order_by
  activity_id: order_by
  challenge_id: order_by
  created_at: order_by
  id: order_by
  user_id: order_by
}

# response of any mutation on the table "feed"
type feed_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [feed!]!
}

# input type for inserting object relation for remote table "feed"
input feed_obj_rel_insert_input {
  data: feed_insert_input!
  on_conflict: feed_on_conflict
}

# on conflict condition type for table "feed"
input feed_on_conflict {
  constraint: feed_constraint!
  update_columns: [feed_update_column!]!
  where: feed_bool_exp
}

# ordering options when selecting data from "feed"
input feed_order_by {
  achievement_id: order_by
  activity: activities_order_by
  activityByActivityIdCreatedAtUserId: activities_order_by
  activity_id: order_by
  challenge: challenge_order_by
  challenge_id: order_by
  created_at: order_by
  feedTypeByFeedType: feed_type_order_by
  feed_type: order_by
  id: order_by
  user: users_order_by
  user_achievement: user_achievement_order_by
  user_id: order_by
}

# primary key columns input for table: "feed"
input feed_pk_columns_input {
  id: Int!
}

# select columns of table "feed"
enum feed_select_column {
  # column name
  achievement_id

  # column name
  activity_id

  # column name
  challenge_id

  # column name
  created_at

  # column name
  feed_type

  # column name
  id

  # column name
  user_id
}

# input type for updating data in table "feed"
input feed_set_input {
  achievement_id: Int
  activity_id: Int
  challenge_id: Int
  created_at: timestamptz
  feed_type: feed_type_enum
  id: Int
  user_id: String
}

# aggregate stddev on columns
type feed_stddev_fields {
  achievement_id: Float
  activity_id: Float
  challenge_id: Float
  id: Float
}

# order by stddev() on columns of table "feed"
input feed_stddev_order_by {
  achievement_id: order_by
  activity_id: order_by
  challenge_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type feed_stddev_pop_fields {
  achievement_id: Float
  activity_id: Float
  challenge_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "feed"
input feed_stddev_pop_order_by {
  achievement_id: order_by
  activity_id: order_by
  challenge_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type feed_stddev_samp_fields {
  achievement_id: Float
  activity_id: Float
  challenge_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "feed"
input feed_stddev_samp_order_by {
  achievement_id: order_by
  activity_id: order_by
  challenge_id: order_by
  id: order_by
}

# aggregate sum on columns
type feed_sum_fields {
  achievement_id: Int
  activity_id: Int
  challenge_id: Int
  id: Int
}

# order by sum() on columns of table "feed"
input feed_sum_order_by {
  achievement_id: order_by
  activity_id: order_by
  challenge_id: order_by
  id: order_by
}

# columns and relationships of "feed_type"
type feed_type {
  # An array relationship
  feeds(
    # distinct select on columns
    distinct_on: [feed_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_order_by!]

    # filter the rows returned
    where: feed_bool_exp
  ): [feed!]!

  # An aggregated array relationship
  feeds_aggregate(
    # distinct select on columns
    distinct_on: [feed_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_order_by!]

    # filter the rows returned
    where: feed_bool_exp
  ): feed_aggregate!
  name: String!
}

# aggregated selection of "feed_type"
type feed_type_aggregate {
  aggregate: feed_type_aggregate_fields
  nodes: [feed_type!]!
}

# aggregate fields of "feed_type"
type feed_type_aggregate_fields {
  count(columns: [feed_type_select_column!], distinct: Boolean): Int
  max: feed_type_max_fields
  min: feed_type_min_fields
}

# order by aggregate values of table "feed_type"
input feed_type_aggregate_order_by {
  count: order_by
  max: feed_type_max_order_by
  min: feed_type_min_order_by
}

# input type for inserting array relation for remote table "feed_type"
input feed_type_arr_rel_insert_input {
  data: [feed_type_insert_input!]!
  on_conflict: feed_type_on_conflict
}

# Boolean expression to filter rows from the table "feed_type". All fields are combined with a logical 'AND'.
input feed_type_bool_exp {
  _and: [feed_type_bool_exp]
  _not: feed_type_bool_exp
  _or: [feed_type_bool_exp]
  feeds: feed_bool_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "feed_type"
enum feed_type_constraint {
  # unique or primary key constraint
  feed_type_pkey
}

enum feed_type_enum {
  ACHIEVEMENT
  ACTIVITY
  CHALLENGE
}

# expression to compare columns of type feed_type_enum. All fields are combined with logical 'AND'.
input feed_type_enum_comparison_exp {
  _eq: feed_type_enum
  _in: [feed_type_enum!]
  _is_null: Boolean
  _neq: feed_type_enum
  _nin: [feed_type_enum!]
}

# input type for inserting data into table "feed_type"
input feed_type_insert_input {
  feeds: feed_arr_rel_insert_input
  name: String
}

# aggregate max on columns
type feed_type_max_fields {
  name: String
}

# order by max() on columns of table "feed_type"
input feed_type_max_order_by {
  name: order_by
}

# aggregate min on columns
type feed_type_min_fields {
  name: String
}

# order by min() on columns of table "feed_type"
input feed_type_min_order_by {
  name: order_by
}

# response of any mutation on the table "feed_type"
type feed_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [feed_type!]!
}

# input type for inserting object relation for remote table "feed_type"
input feed_type_obj_rel_insert_input {
  data: feed_type_insert_input!
  on_conflict: feed_type_on_conflict
}

# on conflict condition type for table "feed_type"
input feed_type_on_conflict {
  constraint: feed_type_constraint!
  update_columns: [feed_type_update_column!]!
  where: feed_type_bool_exp
}

# ordering options when selecting data from "feed_type"
input feed_type_order_by {
  feeds_aggregate: feed_aggregate_order_by
  name: order_by
}

# primary key columns input for table: "feed_type"
input feed_type_pk_columns_input {
  name: String!
}

# select columns of table "feed_type"
enum feed_type_select_column {
  # column name
  name
}

# input type for updating data in table "feed_type"
input feed_type_set_input {
  name: String
}

# update columns of table "feed_type"
enum feed_type_update_column {
  # column name
  name
}

# update columns of table "feed"
enum feed_update_column {
  # column name
  achievement_id

  # column name
  activity_id

  # column name
  challenge_id

  # column name
  created_at

  # column name
  feed_type

  # column name
  id

  # column name
  user_id
}

# aggregate var_pop on columns
type feed_var_pop_fields {
  achievement_id: Float
  activity_id: Float
  challenge_id: Float
  id: Float
}

# order by var_pop() on columns of table "feed"
input feed_var_pop_order_by {
  achievement_id: order_by
  activity_id: order_by
  challenge_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type feed_var_samp_fields {
  achievement_id: Float
  activity_id: Float
  challenge_id: Float
  id: Float
}

# order by var_samp() on columns of table "feed"
input feed_var_samp_order_by {
  achievement_id: order_by
  activity_id: order_by
  challenge_id: order_by
  id: order_by
}

# aggregate variance on columns
type feed_variance_fields {
  achievement_id: Float
  activity_id: Float
  challenge_id: Float
  id: Float
}

# order by variance() on columns of table "feed"
input feed_variance_order_by {
  achievement_id: order_by
  activity_id: order_by
  challenge_id: order_by
  id: order_by
}

scalar float8

# expression to compare columns of type float8. All fields are combined with logical 'AND'.
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

# columns and relationships of "followings"
type followings {
  created_at: timestamptz

  # An object relationship
  follower: users!
  following_id: String!
  updated_at: timestamptz

  # An object relationship
  user: users!
  user_id: String!
}

# aggregated selection of "followings"
type followings_aggregate {
  aggregate: followings_aggregate_fields
  nodes: [followings!]!
}

# aggregate fields of "followings"
type followings_aggregate_fields {
  count(columns: [followings_select_column!], distinct: Boolean): Int
  max: followings_max_fields
  min: followings_min_fields
}

# order by aggregate values of table "followings"
input followings_aggregate_order_by {
  count: order_by
  max: followings_max_order_by
  min: followings_min_order_by
}

# input type for inserting array relation for remote table "followings"
input followings_arr_rel_insert_input {
  data: [followings_insert_input!]!
  on_conflict: followings_on_conflict
}

# Boolean expression to filter rows from the table "followings". All fields are combined with a logical 'AND'.
input followings_bool_exp {
  _and: [followings_bool_exp]
  _not: followings_bool_exp
  _or: [followings_bool_exp]
  created_at: timestamptz_comparison_exp
  follower: users_bool_exp
  following_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

# unique or primary key constraints on table "followings"
enum followings_constraint {
  # unique or primary key constraint
  Followings_pkey
}

# input type for inserting data into table "followings"
input followings_insert_input {
  created_at: timestamptz
  follower: users_obj_rel_insert_input
  following_id: String
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

# aggregate max on columns
type followings_max_fields {
  created_at: timestamptz
  following_id: String
  updated_at: timestamptz
  user_id: String
}

# order by max() on columns of table "followings"
input followings_max_order_by {
  created_at: order_by
  following_id: order_by
  updated_at: order_by
  user_id: order_by
}

# aggregate min on columns
type followings_min_fields {
  created_at: timestamptz
  following_id: String
  updated_at: timestamptz
  user_id: String
}

# order by min() on columns of table "followings"
input followings_min_order_by {
  created_at: order_by
  following_id: order_by
  updated_at: order_by
  user_id: order_by
}

# response of any mutation on the table "followings"
type followings_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [followings!]!
}

# input type for inserting object relation for remote table "followings"
input followings_obj_rel_insert_input {
  data: followings_insert_input!
  on_conflict: followings_on_conflict
}

# on conflict condition type for table "followings"
input followings_on_conflict {
  constraint: followings_constraint!
  update_columns: [followings_update_column!]!
  where: followings_bool_exp
}

# ordering options when selecting data from "followings"
input followings_order_by {
  created_at: order_by
  follower: users_order_by
  following_id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

# primary key columns input for table: "followings"
input followings_pk_columns_input {
  following_id: String!
  user_id: String!
}

# select columns of table "followings"
enum followings_select_column {
  # column name
  created_at

  # column name
  following_id

  # column name
  updated_at

  # column name
  user_id
}

# input type for updating data in table "followings"
input followings_set_input {
  created_at: timestamptz
  following_id: String
  updated_at: timestamptz
  user_id: String
}

# update columns of table "followings"
enum followings_update_column {
  # column name
  created_at

  # column name
  following_id

  # column name
  updated_at

  # column name
  user_id
}

# columns and relationships of "friend_tracking"
type friend_tracking {
  created_at: timestamptz!
  date: date!
  geofence_id: Int!
  id: Int!
  linking_word: String!
  updated_at: timestamptz!

  # An object relationship
  user_join: users
  user_join_id: String

  # An object relationship
  user_start: users!
  user_start_id: String!
}

# aggregated selection of "friend_tracking"
type friend_tracking_aggregate {
  aggregate: friend_tracking_aggregate_fields
  nodes: [friend_tracking!]!
}

# aggregate fields of "friend_tracking"
type friend_tracking_aggregate_fields {
  avg: friend_tracking_avg_fields
  count(columns: [friend_tracking_select_column!], distinct: Boolean): Int
  max: friend_tracking_max_fields
  min: friend_tracking_min_fields
  stddev: friend_tracking_stddev_fields
  stddev_pop: friend_tracking_stddev_pop_fields
  stddev_samp: friend_tracking_stddev_samp_fields
  sum: friend_tracking_sum_fields
  var_pop: friend_tracking_var_pop_fields
  var_samp: friend_tracking_var_samp_fields
  variance: friend_tracking_variance_fields
}

# order by aggregate values of table "friend_tracking"
input friend_tracking_aggregate_order_by {
  avg: friend_tracking_avg_order_by
  count: order_by
  max: friend_tracking_max_order_by
  min: friend_tracking_min_order_by
  stddev: friend_tracking_stddev_order_by
  stddev_pop: friend_tracking_stddev_pop_order_by
  stddev_samp: friend_tracking_stddev_samp_order_by
  sum: friend_tracking_sum_order_by
  var_pop: friend_tracking_var_pop_order_by
  var_samp: friend_tracking_var_samp_order_by
  variance: friend_tracking_variance_order_by
}

# input type for inserting array relation for remote table "friend_tracking"
input friend_tracking_arr_rel_insert_input {
  data: [friend_tracking_insert_input!]!
  on_conflict: friend_tracking_on_conflict
}

# aggregate avg on columns
type friend_tracking_avg_fields {
  geofence_id: Float
  id: Float
}

# order by avg() on columns of table "friend_tracking"
input friend_tracking_avg_order_by {
  geofence_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "friend_tracking". All fields are combined with a logical 'AND'.
input friend_tracking_bool_exp {
  _and: [friend_tracking_bool_exp]
  _not: friend_tracking_bool_exp
  _or: [friend_tracking_bool_exp]
  created_at: timestamptz_comparison_exp
  date: date_comparison_exp
  geofence_id: Int_comparison_exp
  id: Int_comparison_exp
  linking_word: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_join: users_bool_exp
  user_join_id: String_comparison_exp
  user_start: users_bool_exp
  user_start_id: String_comparison_exp
}

# unique or primary key constraints on table "friend_tracking"
enum friend_tracking_constraint {
  # unique or primary key constraint
  friends_tracking_pkey
}

# input type for incrementing integer column in table "friend_tracking"
input friend_tracking_inc_input {
  geofence_id: Int
  id: Int
}

# input type for inserting data into table "friend_tracking"
input friend_tracking_insert_input {
  created_at: timestamptz
  date: date
  geofence_id: Int
  id: Int
  linking_word: String
  updated_at: timestamptz
  user_join: users_obj_rel_insert_input
  user_join_id: String
  user_start: users_obj_rel_insert_input
  user_start_id: String
}

# aggregate max on columns
type friend_tracking_max_fields {
  created_at: timestamptz
  date: date
  geofence_id: Int
  id: Int
  linking_word: String
  updated_at: timestamptz
  user_join_id: String
  user_start_id: String
}

# order by max() on columns of table "friend_tracking"
input friend_tracking_max_order_by {
  created_at: order_by
  date: order_by
  geofence_id: order_by
  id: order_by
  linking_word: order_by
  updated_at: order_by
  user_join_id: order_by
  user_start_id: order_by
}

# aggregate min on columns
type friend_tracking_min_fields {
  created_at: timestamptz
  date: date
  geofence_id: Int
  id: Int
  linking_word: String
  updated_at: timestamptz
  user_join_id: String
  user_start_id: String
}

# order by min() on columns of table "friend_tracking"
input friend_tracking_min_order_by {
  created_at: order_by
  date: order_by
  geofence_id: order_by
  id: order_by
  linking_word: order_by
  updated_at: order_by
  user_join_id: order_by
  user_start_id: order_by
}

# response of any mutation on the table "friend_tracking"
type friend_tracking_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [friend_tracking!]!
}

# input type for inserting object relation for remote table "friend_tracking"
input friend_tracking_obj_rel_insert_input {
  data: friend_tracking_insert_input!
  on_conflict: friend_tracking_on_conflict
}

# on conflict condition type for table "friend_tracking"
input friend_tracking_on_conflict {
  constraint: friend_tracking_constraint!
  update_columns: [friend_tracking_update_column!]!
  where: friend_tracking_bool_exp
}

# ordering options when selecting data from "friend_tracking"
input friend_tracking_order_by {
  created_at: order_by
  date: order_by
  geofence_id: order_by
  id: order_by
  linking_word: order_by
  updated_at: order_by
  user_join: users_order_by
  user_join_id: order_by
  user_start: users_order_by
  user_start_id: order_by
}

# primary key columns input for table: "friend_tracking"
input friend_tracking_pk_columns_input {
  id: Int!
}

# select columns of table "friend_tracking"
enum friend_tracking_select_column {
  # column name
  created_at

  # column name
  date

  # column name
  geofence_id

  # column name
  id

  # column name
  linking_word

  # column name
  updated_at

  # column name
  user_join_id

  # column name
  user_start_id
}

# input type for updating data in table "friend_tracking"
input friend_tracking_set_input {
  created_at: timestamptz
  date: date
  geofence_id: Int
  id: Int
  linking_word: String
  updated_at: timestamptz
  user_join_id: String
  user_start_id: String
}

# aggregate stddev on columns
type friend_tracking_stddev_fields {
  geofence_id: Float
  id: Float
}

# order by stddev() on columns of table "friend_tracking"
input friend_tracking_stddev_order_by {
  geofence_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type friend_tracking_stddev_pop_fields {
  geofence_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "friend_tracking"
input friend_tracking_stddev_pop_order_by {
  geofence_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type friend_tracking_stddev_samp_fields {
  geofence_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "friend_tracking"
input friend_tracking_stddev_samp_order_by {
  geofence_id: order_by
  id: order_by
}

# aggregate sum on columns
type friend_tracking_sum_fields {
  geofence_id: Int
  id: Int
}

# order by sum() on columns of table "friend_tracking"
input friend_tracking_sum_order_by {
  geofence_id: order_by
  id: order_by
}

# update columns of table "friend_tracking"
enum friend_tracking_update_column {
  # column name
  created_at

  # column name
  date

  # column name
  geofence_id

  # column name
  id

  # column name
  linking_word

  # column name
  updated_at

  # column name
  user_join_id

  # column name
  user_start_id
}

# aggregate var_pop on columns
type friend_tracking_var_pop_fields {
  geofence_id: Float
  id: Float
}

# order by var_pop() on columns of table "friend_tracking"
input friend_tracking_var_pop_order_by {
  geofence_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type friend_tracking_var_samp_fields {
  geofence_id: Float
  id: Float
}

# order by var_samp() on columns of table "friend_tracking"
input friend_tracking_var_samp_order_by {
  geofence_id: order_by
  id: order_by
}

# aggregate variance on columns
type friend_tracking_variance_fields {
  geofence_id: Float
  id: Float
}

# order by variance() on columns of table "friend_tracking"
input friend_tracking_variance_order_by {
  geofence_id: order_by
  id: order_by
}

# columns and relationships of "geofence_variants"
type geofence_variants {
  description: String

  # An array relationship
  geofences(
    # distinct select on columns
    distinct_on: [geofences_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [geofences_order_by!]

    # filter the rows returned
    where: geofences_bool_exp
  ): [geofences!]!

  # An aggregated array relationship
  geofences_aggregate(
    # distinct select on columns
    distinct_on: [geofences_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [geofences_order_by!]

    # filter the rows returned
    where: geofences_bool_exp
  ): geofences_aggregate!
  name: String!
}

# aggregated selection of "geofence_variants"
type geofence_variants_aggregate {
  aggregate: geofence_variants_aggregate_fields
  nodes: [geofence_variants!]!
}

# aggregate fields of "geofence_variants"
type geofence_variants_aggregate_fields {
  count(columns: [geofence_variants_select_column!], distinct: Boolean): Int
  max: geofence_variants_max_fields
  min: geofence_variants_min_fields
}

# order by aggregate values of table "geofence_variants"
input geofence_variants_aggregate_order_by {
  count: order_by
  max: geofence_variants_max_order_by
  min: geofence_variants_min_order_by
}

# input type for inserting array relation for remote table "geofence_variants"
input geofence_variants_arr_rel_insert_input {
  data: [geofence_variants_insert_input!]!
  on_conflict: geofence_variants_on_conflict
}

# Boolean expression to filter rows from the table "geofence_variants". All fields are combined with a logical 'AND'.
input geofence_variants_bool_exp {
  _and: [geofence_variants_bool_exp]
  _not: geofence_variants_bool_exp
  _or: [geofence_variants_bool_exp]
  description: String_comparison_exp
  geofences: geofences_bool_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "geofence_variants"
enum geofence_variants_constraint {
  # unique or primary key constraint
  geo_fence_categories_pkey
}

enum geofence_variants_enum {
  # Circle geofence
  CIRCLE

  # Polygon geofence
  POLYGON
}

# expression to compare columns of type geofence_variants_enum. All fields are combined with logical 'AND'.
input geofence_variants_enum_comparison_exp {
  _eq: geofence_variants_enum
  _in: [geofence_variants_enum!]
  _is_null: Boolean
  _neq: geofence_variants_enum
  _nin: [geofence_variants_enum!]
}

# input type for inserting data into table "geofence_variants"
input geofence_variants_insert_input {
  description: String
  geofences: geofences_arr_rel_insert_input
  name: String
}

# aggregate max on columns
type geofence_variants_max_fields {
  description: String
  name: String
}

# order by max() on columns of table "geofence_variants"
input geofence_variants_max_order_by {
  description: order_by
  name: order_by
}

# aggregate min on columns
type geofence_variants_min_fields {
  description: String
  name: String
}

# order by min() on columns of table "geofence_variants"
input geofence_variants_min_order_by {
  description: order_by
  name: order_by
}

# response of any mutation on the table "geofence_variants"
type geofence_variants_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [geofence_variants!]!
}

# input type for inserting object relation for remote table "geofence_variants"
input geofence_variants_obj_rel_insert_input {
  data: geofence_variants_insert_input!
  on_conflict: geofence_variants_on_conflict
}

# on conflict condition type for table "geofence_variants"
input geofence_variants_on_conflict {
  constraint: geofence_variants_constraint!
  update_columns: [geofence_variants_update_column!]!
  where: geofence_variants_bool_exp
}

# ordering options when selecting data from "geofence_variants"
input geofence_variants_order_by {
  description: order_by
  geofences_aggregate: geofences_aggregate_order_by
  name: order_by
}

# primary key columns input for table: "geofence_variants"
input geofence_variants_pk_columns_input {
  name: String!
}

# select columns of table "geofence_variants"
enum geofence_variants_select_column {
  # column name
  description

  # column name
  name
}

# input type for updating data in table "geofence_variants"
input geofence_variants_set_input {
  description: String
  name: String
}

# update columns of table "geofence_variants"
enum geofence_variants_update_column {
  # column name
  description

  # column name
  name
}

# columns and relationships of "geofences"
type geofences {
  # An array relationship
  activities(
    # distinct select on columns
    distinct_on: [activities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [activities_order_by!]

    # filter the rows returned
    where: activities_bool_exp
  ): [activities!]!

  # An aggregated array relationship
  activities_aggregate(
    # distinct select on columns
    distinct_on: [activities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [activities_order_by!]

    # filter the rows returned
    where: activities_bool_exp
  ): activities_aggregate!
  category: String!

  # Only for polygons
  coordinates: String
  created_at: timestamptz!
  description: String

  # An object relationship
  geofenceByCategory: categories!

  # An object relationship
  geofence_variant: geofence_variants!
  id: Int!
  latitude: float8!
  longitude: float8!
  name: String!
  radius: float8!
  updated_at: timestamptz!
  variant: geofence_variants_enum!
}

# aggregated selection of "geofences"
type geofences_aggregate {
  aggregate: geofences_aggregate_fields
  nodes: [geofences!]!
}

# aggregate fields of "geofences"
type geofences_aggregate_fields {
  avg: geofences_avg_fields
  count(columns: [geofences_select_column!], distinct: Boolean): Int
  max: geofences_max_fields
  min: geofences_min_fields
  stddev: geofences_stddev_fields
  stddev_pop: geofences_stddev_pop_fields
  stddev_samp: geofences_stddev_samp_fields
  sum: geofences_sum_fields
  var_pop: geofences_var_pop_fields
  var_samp: geofences_var_samp_fields
  variance: geofences_variance_fields
}

# order by aggregate values of table "geofences"
input geofences_aggregate_order_by {
  avg: geofences_avg_order_by
  count: order_by
  max: geofences_max_order_by
  min: geofences_min_order_by
  stddev: geofences_stddev_order_by
  stddev_pop: geofences_stddev_pop_order_by
  stddev_samp: geofences_stddev_samp_order_by
  sum: geofences_sum_order_by
  var_pop: geofences_var_pop_order_by
  var_samp: geofences_var_samp_order_by
  variance: geofences_variance_order_by
}

# input type for inserting array relation for remote table "geofences"
input geofences_arr_rel_insert_input {
  data: [geofences_insert_input!]!
  on_conflict: geofences_on_conflict
}

# aggregate avg on columns
type geofences_avg_fields {
  id: Float
  latitude: Float
  longitude: Float
  radius: Float
}

# order by avg() on columns of table "geofences"
input geofences_avg_order_by {
  id: order_by
  latitude: order_by
  longitude: order_by
  radius: order_by
}

# Boolean expression to filter rows from the table "geofences". All fields are combined with a logical 'AND'.
input geofences_bool_exp {
  _and: [geofences_bool_exp]
  _not: geofences_bool_exp
  _or: [geofences_bool_exp]
  activities: activities_bool_exp
  category: String_comparison_exp
  coordinates: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  geofenceByCategory: categories_bool_exp
  geofence_variant: geofence_variants_bool_exp
  id: Int_comparison_exp
  latitude: float8_comparison_exp
  longitude: float8_comparison_exp
  name: String_comparison_exp
  radius: float8_comparison_exp
  updated_at: timestamptz_comparison_exp
  variant: geofence_variants_enum_comparison_exp
}

# unique or primary key constraints on table "geofences"
enum geofences_constraint {
  # unique or primary key constraint
  geofences_coordinates_key

  # unique or primary key constraint
  geofences_latitude_longitude_key

  # unique or primary key constraint
  geofences_name_key

  # unique or primary key constraint
  geofences_pkey
}

# input type for incrementing integer column in table "geofences"
input geofences_inc_input {
  id: Int
  latitude: float8
  longitude: float8
  radius: float8
}

# input type for inserting data into table "geofences"
input geofences_insert_input {
  activities: activities_arr_rel_insert_input
  category: String
  coordinates: String
  created_at: timestamptz
  description: String
  geofenceByCategory: categories_obj_rel_insert_input
  geofence_variant: geofence_variants_obj_rel_insert_input
  id: Int
  latitude: float8
  longitude: float8
  name: String
  radius: float8
  updated_at: timestamptz
  variant: geofence_variants_enum
}

# aggregate max on columns
type geofences_max_fields {
  category: String
  coordinates: String
  created_at: timestamptz
  description: String
  id: Int
  latitude: float8
  longitude: float8
  name: String
  radius: float8
  updated_at: timestamptz
}

# order by max() on columns of table "geofences"
input geofences_max_order_by {
  category: order_by
  coordinates: order_by
  created_at: order_by
  description: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  name: order_by
  radius: order_by
  updated_at: order_by
}

# aggregate min on columns
type geofences_min_fields {
  category: String
  coordinates: String
  created_at: timestamptz
  description: String
  id: Int
  latitude: float8
  longitude: float8
  name: String
  radius: float8
  updated_at: timestamptz
}

# order by min() on columns of table "geofences"
input geofences_min_order_by {
  category: order_by
  coordinates: order_by
  created_at: order_by
  description: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  name: order_by
  radius: order_by
  updated_at: order_by
}

# response of any mutation on the table "geofences"
type geofences_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [geofences!]!
}

# input type for inserting object relation for remote table "geofences"
input geofences_obj_rel_insert_input {
  data: geofences_insert_input!
  on_conflict: geofences_on_conflict
}

# on conflict condition type for table "geofences"
input geofences_on_conflict {
  constraint: geofences_constraint!
  update_columns: [geofences_update_column!]!
  where: geofences_bool_exp
}

# ordering options when selecting data from "geofences"
input geofences_order_by {
  activities_aggregate: activities_aggregate_order_by
  category: order_by
  coordinates: order_by
  created_at: order_by
  description: order_by
  geofenceByCategory: categories_order_by
  geofence_variant: geofence_variants_order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  name: order_by
  radius: order_by
  updated_at: order_by
  variant: order_by
}

# primary key columns input for table: "geofences"
input geofences_pk_columns_input {
  id: Int!
}

# select columns of table "geofences"
enum geofences_select_column {
  # column name
  category

  # column name
  coordinates

  # column name
  created_at

  # column name
  description

  # column name
  id

  # column name
  latitude

  # column name
  longitude

  # column name
  name

  # column name
  radius

  # column name
  updated_at

  # column name
  variant
}

# input type for updating data in table "geofences"
input geofences_set_input {
  category: String
  coordinates: String
  created_at: timestamptz
  description: String
  id: Int
  latitude: float8
  longitude: float8
  name: String
  radius: float8
  updated_at: timestamptz
  variant: geofence_variants_enum
}

# aggregate stddev on columns
type geofences_stddev_fields {
  id: Float
  latitude: Float
  longitude: Float
  radius: Float
}

# order by stddev() on columns of table "geofences"
input geofences_stddev_order_by {
  id: order_by
  latitude: order_by
  longitude: order_by
  radius: order_by
}

# aggregate stddev_pop on columns
type geofences_stddev_pop_fields {
  id: Float
  latitude: Float
  longitude: Float
  radius: Float
}

# order by stddev_pop() on columns of table "geofences"
input geofences_stddev_pop_order_by {
  id: order_by
  latitude: order_by
  longitude: order_by
  radius: order_by
}

# aggregate stddev_samp on columns
type geofences_stddev_samp_fields {
  id: Float
  latitude: Float
  longitude: Float
  radius: Float
}

# order by stddev_samp() on columns of table "geofences"
input geofences_stddev_samp_order_by {
  id: order_by
  latitude: order_by
  longitude: order_by
  radius: order_by
}

# aggregate sum on columns
type geofences_sum_fields {
  id: Int
  latitude: float8
  longitude: float8
  radius: float8
}

# order by sum() on columns of table "geofences"
input geofences_sum_order_by {
  id: order_by
  latitude: order_by
  longitude: order_by
  radius: order_by
}

# update columns of table "geofences"
enum geofences_update_column {
  # column name
  category

  # column name
  coordinates

  # column name
  created_at

  # column name
  description

  # column name
  id

  # column name
  latitude

  # column name
  longitude

  # column name
  name

  # column name
  radius

  # column name
  updated_at

  # column name
  variant
}

# aggregate var_pop on columns
type geofences_var_pop_fields {
  id: Float
  latitude: Float
  longitude: Float
  radius: Float
}

# order by var_pop() on columns of table "geofences"
input geofences_var_pop_order_by {
  id: order_by
  latitude: order_by
  longitude: order_by
  radius: order_by
}

# aggregate var_samp on columns
type geofences_var_samp_fields {
  id: Float
  latitude: Float
  longitude: Float
  radius: Float
}

# order by var_samp() on columns of table "geofences"
input geofences_var_samp_order_by {
  id: order_by
  latitude: order_by
  longitude: order_by
  radius: order_by
}

# aggregate variance on columns
type geofences_variance_fields {
  id: Float
  latitude: Float
  longitude: Float
  radius: Float
}

# order by variance() on columns of table "geofences"
input geofences_variance_order_by {
  id: order_by
  latitude: order_by
  longitude: order_by
  radius: order_by
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar interval

# expression to compare columns of type interval. All fields are combined with logical 'AND'.
input interval_comparison_exp {
  _eq: interval
  _gt: interval
  _gte: interval
  _in: [interval!]
  _is_null: Boolean
  _lt: interval
  _lte: interval
  _neq: interval
  _nin: [interval!]
}

scalar json

# expression to compare columns of type json. All fields are combined with logical 'AND'.
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

# columns and relationships of "likes"
type likes {
  # An object relationship
  activity: activities!
  activity_id: Int!
  created_at: timestamptz
  updated_at: timestamptz

  # An object relationship
  user: users!
  user_id: String!
}

# aggregated selection of "likes"
type likes_aggregate {
  aggregate: likes_aggregate_fields
  nodes: [likes!]!
}

# aggregate fields of "likes"
type likes_aggregate_fields {
  avg: likes_avg_fields
  count(columns: [likes_select_column!], distinct: Boolean): Int
  max: likes_max_fields
  min: likes_min_fields
  stddev: likes_stddev_fields
  stddev_pop: likes_stddev_pop_fields
  stddev_samp: likes_stddev_samp_fields
  sum: likes_sum_fields
  var_pop: likes_var_pop_fields
  var_samp: likes_var_samp_fields
  variance: likes_variance_fields
}

# order by aggregate values of table "likes"
input likes_aggregate_order_by {
  avg: likes_avg_order_by
  count: order_by
  max: likes_max_order_by
  min: likes_min_order_by
  stddev: likes_stddev_order_by
  stddev_pop: likes_stddev_pop_order_by
  stddev_samp: likes_stddev_samp_order_by
  sum: likes_sum_order_by
  var_pop: likes_var_pop_order_by
  var_samp: likes_var_samp_order_by
  variance: likes_variance_order_by
}

# input type for inserting array relation for remote table "likes"
input likes_arr_rel_insert_input {
  data: [likes_insert_input!]!
  on_conflict: likes_on_conflict
}

# aggregate avg on columns
type likes_avg_fields {
  activity_id: Float
}

# order by avg() on columns of table "likes"
input likes_avg_order_by {
  activity_id: order_by
}

# Boolean expression to filter rows from the table "likes". All fields are combined with a logical 'AND'.
input likes_bool_exp {
  _and: [likes_bool_exp]
  _not: likes_bool_exp
  _or: [likes_bool_exp]
  activity: activities_bool_exp
  activity_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

# unique or primary key constraints on table "likes"
enum likes_constraint {
  # unique or primary key constraint
  Likes_pkey

  # unique or primary key constraint
  Likes_user_id_activity_id_key
}

# input type for incrementing integer column in table "likes"
input likes_inc_input {
  activity_id: Int
}

# input type for inserting data into table "likes"
input likes_insert_input {
  activity: activities_obj_rel_insert_input
  activity_id: Int
  created_at: timestamptz
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

# aggregate max on columns
type likes_max_fields {
  activity_id: Int
  created_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

# order by max() on columns of table "likes"
input likes_max_order_by {
  activity_id: order_by
  created_at: order_by
  updated_at: order_by
  user_id: order_by
}

# aggregate min on columns
type likes_min_fields {
  activity_id: Int
  created_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

# order by min() on columns of table "likes"
input likes_min_order_by {
  activity_id: order_by
  created_at: order_by
  updated_at: order_by
  user_id: order_by
}

# response of any mutation on the table "likes"
type likes_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [likes!]!
}

# input type for inserting object relation for remote table "likes"
input likes_obj_rel_insert_input {
  data: likes_insert_input!
  on_conflict: likes_on_conflict
}

# on conflict condition type for table "likes"
input likes_on_conflict {
  constraint: likes_constraint!
  update_columns: [likes_update_column!]!
  where: likes_bool_exp
}

# ordering options when selecting data from "likes"
input likes_order_by {
  activity: activities_order_by
  activity_id: order_by
  created_at: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

# primary key columns input for table: "likes"
input likes_pk_columns_input {
  activity_id: Int!
  user_id: String!
}

# select columns of table "likes"
enum likes_select_column {
  # column name
  activity_id

  # column name
  created_at

  # column name
  updated_at

  # column name
  user_id
}

# input type for updating data in table "likes"
input likes_set_input {
  activity_id: Int
  created_at: timestamptz
  updated_at: timestamptz
  user_id: String
}

# aggregate stddev on columns
type likes_stddev_fields {
  activity_id: Float
}

# order by stddev() on columns of table "likes"
input likes_stddev_order_by {
  activity_id: order_by
}

# aggregate stddev_pop on columns
type likes_stddev_pop_fields {
  activity_id: Float
}

# order by stddev_pop() on columns of table "likes"
input likes_stddev_pop_order_by {
  activity_id: order_by
}

# aggregate stddev_samp on columns
type likes_stddev_samp_fields {
  activity_id: Float
}

# order by stddev_samp() on columns of table "likes"
input likes_stddev_samp_order_by {
  activity_id: order_by
}

# aggregate sum on columns
type likes_sum_fields {
  activity_id: Int
}

# order by sum() on columns of table "likes"
input likes_sum_order_by {
  activity_id: order_by
}

# update columns of table "likes"
enum likes_update_column {
  # column name
  activity_id

  # column name
  created_at

  # column name
  updated_at

  # column name
  user_id
}

# aggregate var_pop on columns
type likes_var_pop_fields {
  activity_id: Float
}

# order by var_pop() on columns of table "likes"
input likes_var_pop_order_by {
  activity_id: order_by
}

# aggregate var_samp on columns
type likes_var_samp_fields {
  activity_id: Float
}

# order by var_samp() on columns of table "likes"
input likes_var_samp_order_by {
  activity_id: order_by
}

# aggregate variance on columns
type likes_variance_fields {
  activity_id: Float
}

# order by variance() on columns of table "likes"
input likes_variance_order_by {
  activity_id: order_by
}

# mutation root
type mutation_root {
  # delete data from the table: "achievement"
  delete_achievement(
    # filter the rows which have to be deleted
    where: achievement_bool_exp!
  ): achievement_mutation_response

  # delete single row from the table: "achievement"
  delete_achievement_by_pk(id: Int!): achievement

  # delete data from the table: "achievement_type"
  delete_achievement_type(
    # filter the rows which have to be deleted
    where: achievement_type_bool_exp!
  ): achievement_type_mutation_response

  # delete single row from the table: "achievement_type"
  delete_achievement_type_by_pk(name: String!): achievement_type

  # delete data from the table: "activities"
  delete_activities(
    # filter the rows which have to be deleted
    where: activities_bool_exp!
  ): activities_mutation_response

  # delete single row from the table: "activities"
  delete_activities_by_pk(activity_id: Int!): activities

  # delete data from the table: "categories"
  delete_categories(
    # filter the rows which have to be deleted
    where: categories_bool_exp!
  ): categories_mutation_response

  # delete single row from the table: "categories"
  delete_categories_by_pk(name: String!): categories

  # delete data from the table: "challenge"
  delete_challenge(
    # filter the rows which have to be deleted
    where: challenge_bool_exp!
  ): challenge_mutation_response

  # delete single row from the table: "challenge"
  delete_challenge_by_pk(id: Int!): challenge

  # delete data from the table: "challenge_participant"
  delete_challenge_participant(
    # filter the rows which have to be deleted
    where: challenge_participant_bool_exp!
  ): challenge_participant_mutation_response

  # delete single row from the table: "challenge_participant"
  delete_challenge_participant_by_pk(challenge_id: Int!, user_id: String!): challenge_participant

  # delete data from the table: "challenge_participant_state"
  delete_challenge_participant_state(
    # filter the rows which have to be deleted
    where: challenge_participant_state_bool_exp!
  ): challenge_participant_state_mutation_response

  # delete single row from the table: "challenge_participant_state"
  delete_challenge_participant_state_by_pk(state: String!): challenge_participant_state

  # delete data from the table: "challenge_state"
  delete_challenge_state(
    # filter the rows which have to be deleted
    where: challenge_state_bool_exp!
  ): challenge_state_mutation_response

  # delete single row from the table: "challenge_state"
  delete_challenge_state_by_pk(state: String!): challenge_state

  # delete data from the table: "challenge_type"
  delete_challenge_type(
    # filter the rows which have to be deleted
    where: challenge_type_bool_exp!
  ): challenge_type_mutation_response

  # delete single row from the table: "challenge_type"
  delete_challenge_type_by_pk(name: String!): challenge_type

  # delete single row from the table: "comments"
  delete_comment(comment_id: Int!): comments

  # delete data from the table: "comments"
  delete_comments(
    # filter the rows which have to be deleted
    where: comments_bool_exp!
  ): comments_mutation_response

  # delete data from the table: "feed"
  delete_feed(
    # filter the rows which have to be deleted
    where: feed_bool_exp!
  ): feed_mutation_response

  # delete single row from the table: "feed"
  delete_feed_by_pk(id: Int!): feed

  # delete data from the table: "feed_type"
  delete_feed_type(
    # filter the rows which have to be deleted
    where: feed_type_bool_exp!
  ): feed_type_mutation_response

  # delete single row from the table: "feed_type"
  delete_feed_type_by_pk(name: String!): feed_type

  # delete data from the table: "followings"
  delete_followings(
    # filter the rows which have to be deleted
    where: followings_bool_exp!
  ): followings_mutation_response

  # delete single row from the table: "followings"
  delete_followings_by_pk(following_id: String!, user_id: String!): followings

  # delete data from the table: "friend_tracking"
  delete_friend_tracking(
    # filter the rows which have to be deleted
    where: friend_tracking_bool_exp!
  ): friend_tracking_mutation_response

  # delete single row from the table: "friend_tracking"
  delete_friend_tracking_by_pk(id: Int!): friend_tracking

  # delete data from the table: "geofence_variants"
  delete_geofence_variants(
    # filter the rows which have to be deleted
    where: geofence_variants_bool_exp!
  ): geofence_variants_mutation_response

  # delete single row from the table: "geofence_variants"
  delete_geofence_variants_by_pk(name: String!): geofence_variants

  # delete data from the table: "geofences"
  delete_geofences(
    # filter the rows which have to be deleted
    where: geofences_bool_exp!
  ): geofences_mutation_response

  # delete single row from the table: "geofences"
  delete_geofences_by_pk(id: Int!): geofences

  # delete data from the table: "likes"
  delete_likes(
    # filter the rows which have to be deleted
    where: likes_bool_exp!
  ): likes_mutation_response

  # delete single row from the table: "likes"
  delete_likes_by_pk(activity_id: Int!, user_id: String!): likes

  # delete data from the table: "notifications"
  delete_notifications(
    # filter the rows which have to be deleted
    where: notifications_bool_exp!
  ): notifications_mutation_response

  # delete single row from the table: "notifications"
  delete_notifications_by_pk(id: Int!): notifications

  # delete single row from the table: "users"
  delete_user(id: String!): users

  # delete data from the table: "user_achievement"
  delete_user_achievement(
    # filter the rows which have to be deleted
    where: user_achievement_bool_exp!
  ): user_achievement_mutation_response

  # delete single row from the table: "user_achievement"
  delete_user_achievement_by_pk(achievement_id: Int!, user_id: String!): user_achievement

  # delete data from the table: "users"
  delete_users(
    # filter the rows which have to be deleted
    where: users_bool_exp!
  ): users_mutation_response

  # insert data into the table: "achievement"
  insert_achievement(
    # the rows to be inserted
    objects: [achievement_insert_input!]!

    # on conflict condition
    on_conflict: achievement_on_conflict
  ): achievement_mutation_response

  # insert a single row into the table: "achievement"
  insert_achievement_one(
    # the row to be inserted
    object: achievement_insert_input!

    # on conflict condition
    on_conflict: achievement_on_conflict
  ): achievement

  # insert data into the table: "achievement_type"
  insert_achievement_type(
    # the rows to be inserted
    objects: [achievement_type_insert_input!]!

    # on conflict condition
    on_conflict: achievement_type_on_conflict
  ): achievement_type_mutation_response

  # insert a single row into the table: "achievement_type"
  insert_achievement_type_one(
    # the row to be inserted
    object: achievement_type_insert_input!

    # on conflict condition
    on_conflict: achievement_type_on_conflict
  ): achievement_type

  # insert data into the table: "activities"
  insert_activities(
    # the rows to be inserted
    objects: [activities_insert_input!]!

    # on conflict condition
    on_conflict: activities_on_conflict
  ): activities_mutation_response

  # insert a single row into the table: "activities"
  insert_activities_one(
    # the row to be inserted
    object: activities_insert_input!

    # on conflict condition
    on_conflict: activities_on_conflict
  ): activities

  # insert data into the table: "categories"
  insert_categories(
    # the rows to be inserted
    objects: [categories_insert_input!]!

    # on conflict condition
    on_conflict: categories_on_conflict
  ): categories_mutation_response

  # insert a single row into the table: "categories"
  insert_categories_one(
    # the row to be inserted
    object: categories_insert_input!

    # on conflict condition
    on_conflict: categories_on_conflict
  ): categories

  # insert data into the table: "challenge"
  insert_challenge(
    # the rows to be inserted
    objects: [challenge_insert_input!]!

    # on conflict condition
    on_conflict: challenge_on_conflict
  ): challenge_mutation_response

  # insert a single row into the table: "challenge"
  insert_challenge_one(
    # the row to be inserted
    object: challenge_insert_input!

    # on conflict condition
    on_conflict: challenge_on_conflict
  ): challenge

  # insert data into the table: "challenge_participant"
  insert_challenge_participant(
    # the rows to be inserted
    objects: [challenge_participant_insert_input!]!

    # on conflict condition
    on_conflict: challenge_participant_on_conflict
  ): challenge_participant_mutation_response

  # insert a single row into the table: "challenge_participant"
  insert_challenge_participant_one(
    # the row to be inserted
    object: challenge_participant_insert_input!

    # on conflict condition
    on_conflict: challenge_participant_on_conflict
  ): challenge_participant

  # insert data into the table: "challenge_participant_state"
  insert_challenge_participant_state(
    # the rows to be inserted
    objects: [challenge_participant_state_insert_input!]!

    # on conflict condition
    on_conflict: challenge_participant_state_on_conflict
  ): challenge_participant_state_mutation_response

  # insert a single row into the table: "challenge_participant_state"
  insert_challenge_participant_state_one(
    # the row to be inserted
    object: challenge_participant_state_insert_input!

    # on conflict condition
    on_conflict: challenge_participant_state_on_conflict
  ): challenge_participant_state

  # insert data into the table: "challenge_state"
  insert_challenge_state(
    # the rows to be inserted
    objects: [challenge_state_insert_input!]!

    # on conflict condition
    on_conflict: challenge_state_on_conflict
  ): challenge_state_mutation_response

  # insert a single row into the table: "challenge_state"
  insert_challenge_state_one(
    # the row to be inserted
    object: challenge_state_insert_input!

    # on conflict condition
    on_conflict: challenge_state_on_conflict
  ): challenge_state

  # insert data into the table: "challenge_type"
  insert_challenge_type(
    # the rows to be inserted
    objects: [challenge_type_insert_input!]!

    # on conflict condition
    on_conflict: challenge_type_on_conflict
  ): challenge_type_mutation_response

  # insert a single row into the table: "challenge_type"
  insert_challenge_type_one(
    # the row to be inserted
    object: challenge_type_insert_input!

    # on conflict condition
    on_conflict: challenge_type_on_conflict
  ): challenge_type

  # insert a single row into the table: "comments"
  insert_comment(
    # the row to be inserted
    object: comments_insert_input!

    # on conflict condition
    on_conflict: comments_on_conflict
  ): comments

  # insert data into the table: "comments"
  insert_comments(
    # the rows to be inserted
    objects: [comments_insert_input!]!

    # on conflict condition
    on_conflict: comments_on_conflict
  ): comments_mutation_response

  # insert data into the table: "feed"
  insert_feed(
    # the rows to be inserted
    objects: [feed_insert_input!]!

    # on conflict condition
    on_conflict: feed_on_conflict
  ): feed_mutation_response

  # insert a single row into the table: "feed"
  insert_feed_one(
    # the row to be inserted
    object: feed_insert_input!

    # on conflict condition
    on_conflict: feed_on_conflict
  ): feed

  # insert data into the table: "feed_type"
  insert_feed_type(
    # the rows to be inserted
    objects: [feed_type_insert_input!]!

    # on conflict condition
    on_conflict: feed_type_on_conflict
  ): feed_type_mutation_response

  # insert a single row into the table: "feed_type"
  insert_feed_type_one(
    # the row to be inserted
    object: feed_type_insert_input!

    # on conflict condition
    on_conflict: feed_type_on_conflict
  ): feed_type

  # insert data into the table: "followings"
  insert_followings(
    # the rows to be inserted
    objects: [followings_insert_input!]!

    # on conflict condition
    on_conflict: followings_on_conflict
  ): followings_mutation_response

  # insert a single row into the table: "followings"
  insert_followings_one(
    # the row to be inserted
    object: followings_insert_input!

    # on conflict condition
    on_conflict: followings_on_conflict
  ): followings

  # insert data into the table: "friend_tracking"
  insert_friend_tracking(
    # the rows to be inserted
    objects: [friend_tracking_insert_input!]!

    # on conflict condition
    on_conflict: friend_tracking_on_conflict
  ): friend_tracking_mutation_response

  # insert a single row into the table: "friend_tracking"
  insert_friend_tracking_one(
    # the row to be inserted
    object: friend_tracking_insert_input!

    # on conflict condition
    on_conflict: friend_tracking_on_conflict
  ): friend_tracking

  # insert data into the table: "geofence_variants"
  insert_geofence_variants(
    # the rows to be inserted
    objects: [geofence_variants_insert_input!]!

    # on conflict condition
    on_conflict: geofence_variants_on_conflict
  ): geofence_variants_mutation_response

  # insert a single row into the table: "geofence_variants"
  insert_geofence_variants_one(
    # the row to be inserted
    object: geofence_variants_insert_input!

    # on conflict condition
    on_conflict: geofence_variants_on_conflict
  ): geofence_variants

  # insert data into the table: "geofences"
  insert_geofences(
    # the rows to be inserted
    objects: [geofences_insert_input!]!

    # on conflict condition
    on_conflict: geofences_on_conflict
  ): geofences_mutation_response

  # insert a single row into the table: "geofences"
  insert_geofences_one(
    # the row to be inserted
    object: geofences_insert_input!

    # on conflict condition
    on_conflict: geofences_on_conflict
  ): geofences

  # insert data into the table: "likes"
  insert_likes(
    # the rows to be inserted
    objects: [likes_insert_input!]!

    # on conflict condition
    on_conflict: likes_on_conflict
  ): likes_mutation_response

  # insert a single row into the table: "likes"
  insert_likes_one(
    # the row to be inserted
    object: likes_insert_input!

    # on conflict condition
    on_conflict: likes_on_conflict
  ): likes

  # insert data into the table: "notifications"
  insert_notifications(
    # the rows to be inserted
    objects: [notifications_insert_input!]!

    # on conflict condition
    on_conflict: notifications_on_conflict
  ): notifications_mutation_response

  # insert a single row into the table: "notifications"
  insert_notifications_one(
    # the row to be inserted
    object: notifications_insert_input!

    # on conflict condition
    on_conflict: notifications_on_conflict
  ): notifications

  # insert a single row into the table: "users"
  insert_user(
    # the row to be inserted
    object: users_insert_input!

    # on conflict condition
    on_conflict: users_on_conflict
  ): users

  # insert data into the table: "user_achievement"
  insert_user_achievement(
    # the rows to be inserted
    objects: [user_achievement_insert_input!]!

    # on conflict condition
    on_conflict: user_achievement_on_conflict
  ): user_achievement_mutation_response

  # insert a single row into the table: "user_achievement"
  insert_user_achievement_one(
    # the row to be inserted
    object: user_achievement_insert_input!

    # on conflict condition
    on_conflict: user_achievement_on_conflict
  ): user_achievement

  # insert data into the table: "users"
  insert_users(
    # the rows to be inserted
    objects: [users_insert_input!]!

    # on conflict condition
    on_conflict: users_on_conflict
  ): users_mutation_response

  # update data of the table: "achievement"
  update_achievement(
    # increments the integer columns with given value of the filtered values
    _inc: achievement_inc_input

    # sets the columns of the filtered rows to the given values
    _set: achievement_set_input

    # filter the rows which have to be updated
    where: achievement_bool_exp!
  ): achievement_mutation_response

  # update single row of the table: "achievement"
  update_achievement_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: achievement_inc_input

    # sets the columns of the filtered rows to the given values
    _set: achievement_set_input
    pk_columns: achievement_pk_columns_input!
  ): achievement

  # update data of the table: "achievement_type"
  update_achievement_type(
    # sets the columns of the filtered rows to the given values
    _set: achievement_type_set_input

    # filter the rows which have to be updated
    where: achievement_type_bool_exp!
  ): achievement_type_mutation_response

  # update single row of the table: "achievement_type"
  update_achievement_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: achievement_type_set_input
    pk_columns: achievement_type_pk_columns_input!
  ): achievement_type

  # update data of the table: "activities"
  update_activities(
    # increments the integer columns with given value of the filtered values
    _inc: activities_inc_input

    # sets the columns of the filtered rows to the given values
    _set: activities_set_input

    # filter the rows which have to be updated
    where: activities_bool_exp!
  ): activities_mutation_response

  # update single row of the table: "activities"
  update_activities_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: activities_inc_input

    # sets the columns of the filtered rows to the given values
    _set: activities_set_input
    pk_columns: activities_pk_columns_input!
  ): activities

  # update data of the table: "categories"
  update_categories(
    # increments the integer columns with given value of the filtered values
    _inc: categories_inc_input

    # sets the columns of the filtered rows to the given values
    _set: categories_set_input

    # filter the rows which have to be updated
    where: categories_bool_exp!
  ): categories_mutation_response

  # update single row of the table: "categories"
  update_categories_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: categories_inc_input

    # sets the columns of the filtered rows to the given values
    _set: categories_set_input
    pk_columns: categories_pk_columns_input!
  ): categories

  # update data of the table: "challenge"
  update_challenge(
    # increments the integer columns with given value of the filtered values
    _inc: challenge_inc_input

    # sets the columns of the filtered rows to the given values
    _set: challenge_set_input

    # filter the rows which have to be updated
    where: challenge_bool_exp!
  ): challenge_mutation_response

  # update single row of the table: "challenge"
  update_challenge_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: challenge_inc_input

    # sets the columns of the filtered rows to the given values
    _set: challenge_set_input
    pk_columns: challenge_pk_columns_input!
  ): challenge

  # update data of the table: "challenge_participant"
  update_challenge_participant(
    # increments the integer columns with given value of the filtered values
    _inc: challenge_participant_inc_input

    # sets the columns of the filtered rows to the given values
    _set: challenge_participant_set_input

    # filter the rows which have to be updated
    where: challenge_participant_bool_exp!
  ): challenge_participant_mutation_response

  # update single row of the table: "challenge_participant"
  update_challenge_participant_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: challenge_participant_inc_input

    # sets the columns of the filtered rows to the given values
    _set: challenge_participant_set_input
    pk_columns: challenge_participant_pk_columns_input!
  ): challenge_participant

  # update data of the table: "challenge_participant_state"
  update_challenge_participant_state(
    # sets the columns of the filtered rows to the given values
    _set: challenge_participant_state_set_input

    # filter the rows which have to be updated
    where: challenge_participant_state_bool_exp!
  ): challenge_participant_state_mutation_response

  # update single row of the table: "challenge_participant_state"
  update_challenge_participant_state_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: challenge_participant_state_set_input
    pk_columns: challenge_participant_state_pk_columns_input!
  ): challenge_participant_state

  # update data of the table: "challenge_state"
  update_challenge_state(
    # sets the columns of the filtered rows to the given values
    _set: challenge_state_set_input

    # filter the rows which have to be updated
    where: challenge_state_bool_exp!
  ): challenge_state_mutation_response

  # update single row of the table: "challenge_state"
  update_challenge_state_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: challenge_state_set_input
    pk_columns: challenge_state_pk_columns_input!
  ): challenge_state

  # update data of the table: "challenge_type"
  update_challenge_type(
    # sets the columns of the filtered rows to the given values
    _set: challenge_type_set_input

    # filter the rows which have to be updated
    where: challenge_type_bool_exp!
  ): challenge_type_mutation_response

  # update single row of the table: "challenge_type"
  update_challenge_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: challenge_type_set_input
    pk_columns: challenge_type_pk_columns_input!
  ): challenge_type

  # update single row of the table: "comments"
  update_comment(
    # increments the integer columns with given value of the filtered values
    _inc: comments_inc_input

    # sets the columns of the filtered rows to the given values
    _set: comments_set_input
    pk_columns: comments_pk_columns_input!
  ): comments

  # update data of the table: "comments"
  update_comments(
    # increments the integer columns with given value of the filtered values
    _inc: comments_inc_input

    # sets the columns of the filtered rows to the given values
    _set: comments_set_input

    # filter the rows which have to be updated
    where: comments_bool_exp!
  ): comments_mutation_response

  # update data of the table: "feed"
  update_feed(
    # increments the integer columns with given value of the filtered values
    _inc: feed_inc_input

    # sets the columns of the filtered rows to the given values
    _set: feed_set_input

    # filter the rows which have to be updated
    where: feed_bool_exp!
  ): feed_mutation_response

  # update single row of the table: "feed"
  update_feed_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: feed_inc_input

    # sets the columns of the filtered rows to the given values
    _set: feed_set_input
    pk_columns: feed_pk_columns_input!
  ): feed

  # update data of the table: "feed_type"
  update_feed_type(
    # sets the columns of the filtered rows to the given values
    _set: feed_type_set_input

    # filter the rows which have to be updated
    where: feed_type_bool_exp!
  ): feed_type_mutation_response

  # update single row of the table: "feed_type"
  update_feed_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: feed_type_set_input
    pk_columns: feed_type_pk_columns_input!
  ): feed_type

  # update data of the table: "followings"
  update_followings(
    # sets the columns of the filtered rows to the given values
    _set: followings_set_input

    # filter the rows which have to be updated
    where: followings_bool_exp!
  ): followings_mutation_response

  # update single row of the table: "followings"
  update_followings_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: followings_set_input
    pk_columns: followings_pk_columns_input!
  ): followings

  # update data of the table: "friend_tracking"
  update_friend_tracking(
    # increments the integer columns with given value of the filtered values
    _inc: friend_tracking_inc_input

    # sets the columns of the filtered rows to the given values
    _set: friend_tracking_set_input

    # filter the rows which have to be updated
    where: friend_tracking_bool_exp!
  ): friend_tracking_mutation_response

  # update single row of the table: "friend_tracking"
  update_friend_tracking_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: friend_tracking_inc_input

    # sets the columns of the filtered rows to the given values
    _set: friend_tracking_set_input
    pk_columns: friend_tracking_pk_columns_input!
  ): friend_tracking

  # update data of the table: "geofence_variants"
  update_geofence_variants(
    # sets the columns of the filtered rows to the given values
    _set: geofence_variants_set_input

    # filter the rows which have to be updated
    where: geofence_variants_bool_exp!
  ): geofence_variants_mutation_response

  # update single row of the table: "geofence_variants"
  update_geofence_variants_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: geofence_variants_set_input
    pk_columns: geofence_variants_pk_columns_input!
  ): geofence_variants

  # update data of the table: "geofences"
  update_geofences(
    # increments the integer columns with given value of the filtered values
    _inc: geofences_inc_input

    # sets the columns of the filtered rows to the given values
    _set: geofences_set_input

    # filter the rows which have to be updated
    where: geofences_bool_exp!
  ): geofences_mutation_response

  # update single row of the table: "geofences"
  update_geofences_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: geofences_inc_input

    # sets the columns of the filtered rows to the given values
    _set: geofences_set_input
    pk_columns: geofences_pk_columns_input!
  ): geofences

  # update data of the table: "likes"
  update_likes(
    # increments the integer columns with given value of the filtered values
    _inc: likes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: likes_set_input

    # filter the rows which have to be updated
    where: likes_bool_exp!
  ): likes_mutation_response

  # update single row of the table: "likes"
  update_likes_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: likes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: likes_set_input
    pk_columns: likes_pk_columns_input!
  ): likes

  # update data of the table: "notifications"
  update_notifications(
    # increments the integer columns with given value of the filtered values
    _inc: notifications_inc_input

    # sets the columns of the filtered rows to the given values
    _set: notifications_set_input

    # filter the rows which have to be updated
    where: notifications_bool_exp!
  ): notifications_mutation_response

  # update single row of the table: "notifications"
  update_notifications_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: notifications_inc_input

    # sets the columns of the filtered rows to the given values
    _set: notifications_set_input
    pk_columns: notifications_pk_columns_input!
  ): notifications

  # update single row of the table: "users"
  update_user(
    # sets the columns of the filtered rows to the given values
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  # update data of the table: "user_achievement"
  update_user_achievement(
    # increments the integer columns with given value of the filtered values
    _inc: user_achievement_inc_input

    # sets the columns of the filtered rows to the given values
    _set: user_achievement_set_input

    # filter the rows which have to be updated
    where: user_achievement_bool_exp!
  ): user_achievement_mutation_response

  # update single row of the table: "user_achievement"
  update_user_achievement_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: user_achievement_inc_input

    # sets the columns of the filtered rows to the given values
    _set: user_achievement_set_input
    pk_columns: user_achievement_pk_columns_input!
  ): user_achievement

  # update data of the table: "users"
  update_users(
    # sets the columns of the filtered rows to the given values
    _set: users_set_input

    # filter the rows which have to be updated
    where: users_bool_exp!
  ): users_mutation_response
}

# columns and relationships of "notifications"
type notifications {
  id: Int!
  seen: Boolean!
  text: String!
  user_id: String!
}

# aggregated selection of "notifications"
type notifications_aggregate {
  aggregate: notifications_aggregate_fields
  nodes: [notifications!]!
}

# aggregate fields of "notifications"
type notifications_aggregate_fields {
  avg: notifications_avg_fields
  count(columns: [notifications_select_column!], distinct: Boolean): Int
  max: notifications_max_fields
  min: notifications_min_fields
  stddev: notifications_stddev_fields
  stddev_pop: notifications_stddev_pop_fields
  stddev_samp: notifications_stddev_samp_fields
  sum: notifications_sum_fields
  var_pop: notifications_var_pop_fields
  var_samp: notifications_var_samp_fields
  variance: notifications_variance_fields
}

# order by aggregate values of table "notifications"
input notifications_aggregate_order_by {
  avg: notifications_avg_order_by
  count: order_by
  max: notifications_max_order_by
  min: notifications_min_order_by
  stddev: notifications_stddev_order_by
  stddev_pop: notifications_stddev_pop_order_by
  stddev_samp: notifications_stddev_samp_order_by
  sum: notifications_sum_order_by
  var_pop: notifications_var_pop_order_by
  var_samp: notifications_var_samp_order_by
  variance: notifications_variance_order_by
}

# input type for inserting array relation for remote table "notifications"
input notifications_arr_rel_insert_input {
  data: [notifications_insert_input!]!
  on_conflict: notifications_on_conflict
}

# aggregate avg on columns
type notifications_avg_fields {
  id: Float
}

# order by avg() on columns of table "notifications"
input notifications_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'.
input notifications_bool_exp {
  _and: [notifications_bool_exp]
  _not: notifications_bool_exp
  _or: [notifications_bool_exp]
  id: Int_comparison_exp
  seen: Boolean_comparison_exp
  text: String_comparison_exp
  user_id: String_comparison_exp
}

# unique or primary key constraints on table "notifications"
enum notifications_constraint {
  # unique or primary key constraint
  notifications_pkey
}

# input type for incrementing integer column in table "notifications"
input notifications_inc_input {
  id: Int
}

# input type for inserting data into table "notifications"
input notifications_insert_input {
  id: Int
  seen: Boolean
  text: String
  user_id: String
}

# aggregate max on columns
type notifications_max_fields {
  id: Int
  text: String
  user_id: String
}

# order by max() on columns of table "notifications"
input notifications_max_order_by {
  id: order_by
  text: order_by
  user_id: order_by
}

# aggregate min on columns
type notifications_min_fields {
  id: Int
  text: String
  user_id: String
}

# order by min() on columns of table "notifications"
input notifications_min_order_by {
  id: order_by
  text: order_by
  user_id: order_by
}

# response of any mutation on the table "notifications"
type notifications_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [notifications!]!
}

# input type for inserting object relation for remote table "notifications"
input notifications_obj_rel_insert_input {
  data: notifications_insert_input!
  on_conflict: notifications_on_conflict
}

# on conflict condition type for table "notifications"
input notifications_on_conflict {
  constraint: notifications_constraint!
  update_columns: [notifications_update_column!]!
  where: notifications_bool_exp
}

# ordering options when selecting data from "notifications"
input notifications_order_by {
  id: order_by
  seen: order_by
  text: order_by
  user_id: order_by
}

# primary key columns input for table: "notifications"
input notifications_pk_columns_input {
  id: Int!
}

# select columns of table "notifications"
enum notifications_select_column {
  # column name
  id

  # column name
  seen

  # column name
  text

  # column name
  user_id
}

# input type for updating data in table "notifications"
input notifications_set_input {
  id: Int
  seen: Boolean
  text: String
  user_id: String
}

# aggregate stddev on columns
type notifications_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "notifications"
input notifications_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type notifications_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "notifications"
input notifications_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type notifications_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "notifications"
input notifications_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type notifications_sum_fields {
  id: Int
}

# order by sum() on columns of table "notifications"
input notifications_sum_order_by {
  id: order_by
}

# update columns of table "notifications"
enum notifications_update_column {
  # column name
  id

  # column name
  seen

  # column name
  text

  # column name
  user_id
}

# aggregate var_pop on columns
type notifications_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "notifications"
input notifications_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type notifications_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "notifications"
input notifications_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type notifications_variance_fields {
  id: Float
}

# order by variance() on columns of table "notifications"
input notifications_variance_order_by {
  id: order_by
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# query root
type query_root {
  # fetch data from the table: "achievement"
  achievement(
    # distinct select on columns
    distinct_on: [achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_order_by!]

    # filter the rows returned
    where: achievement_bool_exp
  ): [achievement!]!

  # fetch aggregated fields from the table: "achievement"
  achievement_aggregate(
    # distinct select on columns
    distinct_on: [achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_order_by!]

    # filter the rows returned
    where: achievement_bool_exp
  ): achievement_aggregate!

  # fetch data from the table: "achievement" using primary key columns
  achievement_by_pk(id: Int!): achievement

  # fetch data from the table: "achievement_type"
  achievement_type(
    # distinct select on columns
    distinct_on: [achievement_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_type_order_by!]

    # filter the rows returned
    where: achievement_type_bool_exp
  ): [achievement_type!]!

  # fetch aggregated fields from the table: "achievement_type"
  achievement_type_aggregate(
    # distinct select on columns
    distinct_on: [achievement_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_type_order_by!]

    # filter the rows returned
    where: achievement_type_bool_exp
  ): achievement_type_aggregate!

  # fetch data from the table: "achievement_type" using primary key columns
  achievement_type_by_pk(name: String!): achievement_type

  # fetch data from the table: "activities"
  activities(
    # distinct select on columns
    distinct_on: [activities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [activities_order_by!]

    # filter the rows returned
    where: activities_bool_exp
  ): [activities!]!

  # fetch aggregated fields from the table: "activities"
  activities_aggregate(
    # distinct select on columns
    distinct_on: [activities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [activities_order_by!]

    # filter the rows returned
    where: activities_bool_exp
  ): activities_aggregate!

  # fetch data from the table: "activities" using primary key columns
  activities_by_pk(activity_id: Int!): activities

  # fetch data from the table: "categories"
  categories(
    # distinct select on columns
    distinct_on: [categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [categories_order_by!]

    # filter the rows returned
    where: categories_bool_exp
  ): [categories!]!

  # fetch aggregated fields from the table: "categories"
  categories_aggregate(
    # distinct select on columns
    distinct_on: [categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [categories_order_by!]

    # filter the rows returned
    where: categories_bool_exp
  ): categories_aggregate!

  # fetch data from the table: "categories" using primary key columns
  categories_by_pk(name: String!): categories

  # fetch data from the table: "challenge"
  challenge(
    # distinct select on columns
    distinct_on: [challenge_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_order_by!]

    # filter the rows returned
    where: challenge_bool_exp
  ): [challenge!]!

  # fetch aggregated fields from the table: "challenge"
  challenge_aggregate(
    # distinct select on columns
    distinct_on: [challenge_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_order_by!]

    # filter the rows returned
    where: challenge_bool_exp
  ): challenge_aggregate!

  # fetch data from the table: "challenge" using primary key columns
  challenge_by_pk(id: Int!): challenge

  # fetch data from the table: "challenge_participant"
  challenge_participant(
    # distinct select on columns
    distinct_on: [challenge_participant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_order_by!]

    # filter the rows returned
    where: challenge_participant_bool_exp
  ): [challenge_participant!]!

  # fetch aggregated fields from the table: "challenge_participant"
  challenge_participant_aggregate(
    # distinct select on columns
    distinct_on: [challenge_participant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_order_by!]

    # filter the rows returned
    where: challenge_participant_bool_exp
  ): challenge_participant_aggregate!

  # fetch data from the table: "challenge_participant" using primary key columns
  challenge_participant_by_pk(challenge_id: Int!, user_id: String!): challenge_participant

  # fetch data from the table: "challenge_participant_state"
  challenge_participant_state(
    # distinct select on columns
    distinct_on: [challenge_participant_state_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_state_order_by!]

    # filter the rows returned
    where: challenge_participant_state_bool_exp
  ): [challenge_participant_state!]!

  # fetch aggregated fields from the table: "challenge_participant_state"
  challenge_participant_state_aggregate(
    # distinct select on columns
    distinct_on: [challenge_participant_state_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_state_order_by!]

    # filter the rows returned
    where: challenge_participant_state_bool_exp
  ): challenge_participant_state_aggregate!

  # fetch data from the table: "challenge_participant_state" using primary key columns
  challenge_participant_state_by_pk(state: String!): challenge_participant_state

  # fetch data from the table: "challenge_state"
  challenge_state(
    # distinct select on columns
    distinct_on: [challenge_state_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_state_order_by!]

    # filter the rows returned
    where: challenge_state_bool_exp
  ): [challenge_state!]!

  # fetch aggregated fields from the table: "challenge_state"
  challenge_state_aggregate(
    # distinct select on columns
    distinct_on: [challenge_state_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_state_order_by!]

    # filter the rows returned
    where: challenge_state_bool_exp
  ): challenge_state_aggregate!

  # fetch data from the table: "challenge_state" using primary key columns
  challenge_state_by_pk(state: String!): challenge_state

  # fetch data from the table: "challenge_type"
  challenge_type(
    # distinct select on columns
    distinct_on: [challenge_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_type_order_by!]

    # filter the rows returned
    where: challenge_type_bool_exp
  ): [challenge_type!]!

  # fetch aggregated fields from the table: "challenge_type"
  challenge_type_aggregate(
    # distinct select on columns
    distinct_on: [challenge_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_type_order_by!]

    # filter the rows returned
    where: challenge_type_bool_exp
  ): challenge_type_aggregate!

  # fetch data from the table: "challenge_type" using primary key columns
  challenge_type_by_pk(name: String!): challenge_type

  # fetch data from the table: "comments" using primary key columns
  comment(comment_id: Int!): comments

  # fetch data from the table: "comments"
  comments(
    # distinct select on columns
    distinct_on: [comments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [comments_order_by!]

    # filter the rows returned
    where: comments_bool_exp
  ): [comments!]!

  # fetch aggregated fields from the table: "comments"
  comments_aggregate(
    # distinct select on columns
    distinct_on: [comments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [comments_order_by!]

    # filter the rows returned
    where: comments_bool_exp
  ): comments_aggregate!

  # fetch data from the table: "feed"
  feed(
    # distinct select on columns
    distinct_on: [feed_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_order_by!]

    # filter the rows returned
    where: feed_bool_exp
  ): [feed!]!

  # fetch aggregated fields from the table: "feed"
  feed_aggregate(
    # distinct select on columns
    distinct_on: [feed_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_order_by!]

    # filter the rows returned
    where: feed_bool_exp
  ): feed_aggregate!

  # fetch data from the table: "feed" using primary key columns
  feed_by_pk(id: Int!): feed

  # fetch data from the table: "feed_type"
  feed_type(
    # distinct select on columns
    distinct_on: [feed_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_type_order_by!]

    # filter the rows returned
    where: feed_type_bool_exp
  ): [feed_type!]!

  # fetch aggregated fields from the table: "feed_type"
  feed_type_aggregate(
    # distinct select on columns
    distinct_on: [feed_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_type_order_by!]

    # filter the rows returned
    where: feed_type_bool_exp
  ): feed_type_aggregate!

  # fetch data from the table: "feed_type" using primary key columns
  feed_type_by_pk(name: String!): feed_type

  # fetch data from the table: "followings"
  followings(
    # distinct select on columns
    distinct_on: [followings_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [followings_order_by!]

    # filter the rows returned
    where: followings_bool_exp
  ): [followings!]!

  # fetch aggregated fields from the table: "followings"
  followings_aggregate(
    # distinct select on columns
    distinct_on: [followings_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [followings_order_by!]

    # filter the rows returned
    where: followings_bool_exp
  ): followings_aggregate!

  # fetch data from the table: "followings" using primary key columns
  followings_by_pk(following_id: String!, user_id: String!): followings

  # fetch data from the table: "friend_tracking"
  friend_tracking(
    # distinct select on columns
    distinct_on: [friend_tracking_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_tracking_order_by!]

    # filter the rows returned
    where: friend_tracking_bool_exp
  ): [friend_tracking!]!

  # fetch aggregated fields from the table: "friend_tracking"
  friend_tracking_aggregate(
    # distinct select on columns
    distinct_on: [friend_tracking_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_tracking_order_by!]

    # filter the rows returned
    where: friend_tracking_bool_exp
  ): friend_tracking_aggregate!

  # fetch data from the table: "friend_tracking" using primary key columns
  friend_tracking_by_pk(id: Int!): friend_tracking

  # fetch data from the table: "geofence_variants"
  geofence_variants(
    # distinct select on columns
    distinct_on: [geofence_variants_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [geofence_variants_order_by!]

    # filter the rows returned
    where: geofence_variants_bool_exp
  ): [geofence_variants!]!

  # fetch aggregated fields from the table: "geofence_variants"
  geofence_variants_aggregate(
    # distinct select on columns
    distinct_on: [geofence_variants_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [geofence_variants_order_by!]

    # filter the rows returned
    where: geofence_variants_bool_exp
  ): geofence_variants_aggregate!

  # fetch data from the table: "geofence_variants" using primary key columns
  geofence_variants_by_pk(name: String!): geofence_variants

  # fetch data from the table: "geofences"
  geofences(
    # distinct select on columns
    distinct_on: [geofences_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [geofences_order_by!]

    # filter the rows returned
    where: geofences_bool_exp
  ): [geofences!]!

  # fetch aggregated fields from the table: "geofences"
  geofences_aggregate(
    # distinct select on columns
    distinct_on: [geofences_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [geofences_order_by!]

    # filter the rows returned
    where: geofences_bool_exp
  ): geofences_aggregate!

  # fetch data from the table: "geofences" using primary key columns
  geofences_by_pk(id: Int!): geofences

  # fetch data from the table: "likes"
  likes(
    # distinct select on columns
    distinct_on: [likes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [likes_order_by!]

    # filter the rows returned
    where: likes_bool_exp
  ): [likes!]!

  # fetch aggregated fields from the table: "likes"
  likes_aggregate(
    # distinct select on columns
    distinct_on: [likes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [likes_order_by!]

    # filter the rows returned
    where: likes_bool_exp
  ): likes_aggregate!

  # fetch data from the table: "likes" using primary key columns
  likes_by_pk(activity_id: Int!, user_id: String!): likes

  # fetch data from the table: "notifications"
  notifications(
    # distinct select on columns
    distinct_on: [notifications_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notifications_order_by!]

    # filter the rows returned
    where: notifications_bool_exp
  ): [notifications!]!

  # fetch aggregated fields from the table: "notifications"
  notifications_aggregate(
    # distinct select on columns
    distinct_on: [notifications_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notifications_order_by!]

    # filter the rows returned
    where: notifications_bool_exp
  ): notifications_aggregate!

  # fetch data from the table: "notifications" using primary key columns
  notifications_by_pk(id: Int!): notifications

  # execute function "unachievedachievements" which returns "achievement"
  unachievedachievements(
    # input parameters for function "unachievedachievements"
    args: unachievedachievements_args!

    # distinct select on columns
    distinct_on: [achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_order_by!]

    # filter the rows returned
    where: achievement_bool_exp
  ): [achievement!]!

  # execute function "unachievedachievements" and query aggregates on result of table type "achievement"
  unachievedachievements_aggregate(
    # input parameters for function "unachievedachievements"
    args: unachievedachievements_args!

    # distinct select on columns
    distinct_on: [achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_order_by!]

    # filter the rows returned
    where: achievement_bool_exp
  ): achievement_aggregate!

  # fetch data from the table: "users" using primary key columns
  user(id: String!): users

  # fetch data from the table: "user_achievement"
  user_achievement(
    # distinct select on columns
    distinct_on: [user_achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_achievement_order_by!]

    # filter the rows returned
    where: user_achievement_bool_exp
  ): [user_achievement!]!

  # fetch aggregated fields from the table: "user_achievement"
  user_achievement_aggregate(
    # distinct select on columns
    distinct_on: [user_achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_achievement_order_by!]

    # filter the rows returned
    where: user_achievement_bool_exp
  ): user_achievement_aggregate!

  # fetch data from the table: "user_achievement" using primary key columns
  user_achievement_by_pk(achievement_id: Int!, user_id: String!): user_achievement

  # fetch data from the table: "users"
  users(
    # distinct select on columns
    distinct_on: [users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [users_order_by!]

    # filter the rows returned
    where: users_bool_exp
  ): [users!]!

  # fetch aggregated fields from the table: "users"
  users_aggregate(
    # distinct select on columns
    distinct_on: [users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [users_order_by!]

    # filter the rows returned
    where: users_bool_exp
  ): users_aggregate!
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "achievement"
  achievement(
    # distinct select on columns
    distinct_on: [achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_order_by!]

    # filter the rows returned
    where: achievement_bool_exp
  ): [achievement!]!

  # fetch aggregated fields from the table: "achievement"
  achievement_aggregate(
    # distinct select on columns
    distinct_on: [achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_order_by!]

    # filter the rows returned
    where: achievement_bool_exp
  ): achievement_aggregate!

  # fetch data from the table: "achievement" using primary key columns
  achievement_by_pk(id: Int!): achievement

  # fetch data from the table: "achievement_type"
  achievement_type(
    # distinct select on columns
    distinct_on: [achievement_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_type_order_by!]

    # filter the rows returned
    where: achievement_type_bool_exp
  ): [achievement_type!]!

  # fetch aggregated fields from the table: "achievement_type"
  achievement_type_aggregate(
    # distinct select on columns
    distinct_on: [achievement_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_type_order_by!]

    # filter the rows returned
    where: achievement_type_bool_exp
  ): achievement_type_aggregate!

  # fetch data from the table: "achievement_type" using primary key columns
  achievement_type_by_pk(name: String!): achievement_type

  # fetch data from the table: "activities"
  activities(
    # distinct select on columns
    distinct_on: [activities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [activities_order_by!]

    # filter the rows returned
    where: activities_bool_exp
  ): [activities!]!

  # fetch aggregated fields from the table: "activities"
  activities_aggregate(
    # distinct select on columns
    distinct_on: [activities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [activities_order_by!]

    # filter the rows returned
    where: activities_bool_exp
  ): activities_aggregate!

  # fetch data from the table: "activities" using primary key columns
  activities_by_pk(activity_id: Int!): activities

  # fetch data from the table: "categories"
  categories(
    # distinct select on columns
    distinct_on: [categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [categories_order_by!]

    # filter the rows returned
    where: categories_bool_exp
  ): [categories!]!

  # fetch aggregated fields from the table: "categories"
  categories_aggregate(
    # distinct select on columns
    distinct_on: [categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [categories_order_by!]

    # filter the rows returned
    where: categories_bool_exp
  ): categories_aggregate!

  # fetch data from the table: "categories" using primary key columns
  categories_by_pk(name: String!): categories

  # fetch data from the table: "challenge"
  challenge(
    # distinct select on columns
    distinct_on: [challenge_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_order_by!]

    # filter the rows returned
    where: challenge_bool_exp
  ): [challenge!]!

  # fetch aggregated fields from the table: "challenge"
  challenge_aggregate(
    # distinct select on columns
    distinct_on: [challenge_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_order_by!]

    # filter the rows returned
    where: challenge_bool_exp
  ): challenge_aggregate!

  # fetch data from the table: "challenge" using primary key columns
  challenge_by_pk(id: Int!): challenge

  # fetch data from the table: "challenge_participant"
  challenge_participant(
    # distinct select on columns
    distinct_on: [challenge_participant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_order_by!]

    # filter the rows returned
    where: challenge_participant_bool_exp
  ): [challenge_participant!]!

  # fetch aggregated fields from the table: "challenge_participant"
  challenge_participant_aggregate(
    # distinct select on columns
    distinct_on: [challenge_participant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_order_by!]

    # filter the rows returned
    where: challenge_participant_bool_exp
  ): challenge_participant_aggregate!

  # fetch data from the table: "challenge_participant" using primary key columns
  challenge_participant_by_pk(challenge_id: Int!, user_id: String!): challenge_participant

  # fetch data from the table: "challenge_participant_state"
  challenge_participant_state(
    # distinct select on columns
    distinct_on: [challenge_participant_state_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_state_order_by!]

    # filter the rows returned
    where: challenge_participant_state_bool_exp
  ): [challenge_participant_state!]!

  # fetch aggregated fields from the table: "challenge_participant_state"
  challenge_participant_state_aggregate(
    # distinct select on columns
    distinct_on: [challenge_participant_state_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_state_order_by!]

    # filter the rows returned
    where: challenge_participant_state_bool_exp
  ): challenge_participant_state_aggregate!

  # fetch data from the table: "challenge_participant_state" using primary key columns
  challenge_participant_state_by_pk(state: String!): challenge_participant_state

  # fetch data from the table: "challenge_state"
  challenge_state(
    # distinct select on columns
    distinct_on: [challenge_state_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_state_order_by!]

    # filter the rows returned
    where: challenge_state_bool_exp
  ): [challenge_state!]!

  # fetch aggregated fields from the table: "challenge_state"
  challenge_state_aggregate(
    # distinct select on columns
    distinct_on: [challenge_state_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_state_order_by!]

    # filter the rows returned
    where: challenge_state_bool_exp
  ): challenge_state_aggregate!

  # fetch data from the table: "challenge_state" using primary key columns
  challenge_state_by_pk(state: String!): challenge_state

  # fetch data from the table: "challenge_type"
  challenge_type(
    # distinct select on columns
    distinct_on: [challenge_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_type_order_by!]

    # filter the rows returned
    where: challenge_type_bool_exp
  ): [challenge_type!]!

  # fetch aggregated fields from the table: "challenge_type"
  challenge_type_aggregate(
    # distinct select on columns
    distinct_on: [challenge_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_type_order_by!]

    # filter the rows returned
    where: challenge_type_bool_exp
  ): challenge_type_aggregate!

  # fetch data from the table: "challenge_type" using primary key columns
  challenge_type_by_pk(name: String!): challenge_type

  # fetch data from the table: "comments" using primary key columns
  comment(comment_id: Int!): comments

  # fetch data from the table: "comments"
  comments(
    # distinct select on columns
    distinct_on: [comments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [comments_order_by!]

    # filter the rows returned
    where: comments_bool_exp
  ): [comments!]!

  # fetch aggregated fields from the table: "comments"
  comments_aggregate(
    # distinct select on columns
    distinct_on: [comments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [comments_order_by!]

    # filter the rows returned
    where: comments_bool_exp
  ): comments_aggregate!

  # fetch data from the table: "feed"
  feed(
    # distinct select on columns
    distinct_on: [feed_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_order_by!]

    # filter the rows returned
    where: feed_bool_exp
  ): [feed!]!

  # fetch aggregated fields from the table: "feed"
  feed_aggregate(
    # distinct select on columns
    distinct_on: [feed_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_order_by!]

    # filter the rows returned
    where: feed_bool_exp
  ): feed_aggregate!

  # fetch data from the table: "feed" using primary key columns
  feed_by_pk(id: Int!): feed

  # fetch data from the table: "feed_type"
  feed_type(
    # distinct select on columns
    distinct_on: [feed_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_type_order_by!]

    # filter the rows returned
    where: feed_type_bool_exp
  ): [feed_type!]!

  # fetch aggregated fields from the table: "feed_type"
  feed_type_aggregate(
    # distinct select on columns
    distinct_on: [feed_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [feed_type_order_by!]

    # filter the rows returned
    where: feed_type_bool_exp
  ): feed_type_aggregate!

  # fetch data from the table: "feed_type" using primary key columns
  feed_type_by_pk(name: String!): feed_type

  # fetch data from the table: "followings"
  followings(
    # distinct select on columns
    distinct_on: [followings_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [followings_order_by!]

    # filter the rows returned
    where: followings_bool_exp
  ): [followings!]!

  # fetch aggregated fields from the table: "followings"
  followings_aggregate(
    # distinct select on columns
    distinct_on: [followings_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [followings_order_by!]

    # filter the rows returned
    where: followings_bool_exp
  ): followings_aggregate!

  # fetch data from the table: "followings" using primary key columns
  followings_by_pk(following_id: String!, user_id: String!): followings

  # fetch data from the table: "friend_tracking"
  friend_tracking(
    # distinct select on columns
    distinct_on: [friend_tracking_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_tracking_order_by!]

    # filter the rows returned
    where: friend_tracking_bool_exp
  ): [friend_tracking!]!

  # fetch aggregated fields from the table: "friend_tracking"
  friend_tracking_aggregate(
    # distinct select on columns
    distinct_on: [friend_tracking_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [friend_tracking_order_by!]

    # filter the rows returned
    where: friend_tracking_bool_exp
  ): friend_tracking_aggregate!

  # fetch data from the table: "friend_tracking" using primary key columns
  friend_tracking_by_pk(id: Int!): friend_tracking

  # fetch data from the table: "geofence_variants"
  geofence_variants(
    # distinct select on columns
    distinct_on: [geofence_variants_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [geofence_variants_order_by!]

    # filter the rows returned
    where: geofence_variants_bool_exp
  ): [geofence_variants!]!

  # fetch aggregated fields from the table: "geofence_variants"
  geofence_variants_aggregate(
    # distinct select on columns
    distinct_on: [geofence_variants_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [geofence_variants_order_by!]

    # filter the rows returned
    where: geofence_variants_bool_exp
  ): geofence_variants_aggregate!

  # fetch data from the table: "geofence_variants" using primary key columns
  geofence_variants_by_pk(name: String!): geofence_variants

  # fetch data from the table: "geofences"
  geofences(
    # distinct select on columns
    distinct_on: [geofences_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [geofences_order_by!]

    # filter the rows returned
    where: geofences_bool_exp
  ): [geofences!]!

  # fetch aggregated fields from the table: "geofences"
  geofences_aggregate(
    # distinct select on columns
    distinct_on: [geofences_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [geofences_order_by!]

    # filter the rows returned
    where: geofences_bool_exp
  ): geofences_aggregate!

  # fetch data from the table: "geofences" using primary key columns
  geofences_by_pk(id: Int!): geofences

  # fetch data from the table: "likes"
  likes(
    # distinct select on columns
    distinct_on: [likes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [likes_order_by!]

    # filter the rows returned
    where: likes_bool_exp
  ): [likes!]!

  # fetch aggregated fields from the table: "likes"
  likes_aggregate(
    # distinct select on columns
    distinct_on: [likes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [likes_order_by!]

    # filter the rows returned
    where: likes_bool_exp
  ): likes_aggregate!

  # fetch data from the table: "likes" using primary key columns
  likes_by_pk(activity_id: Int!, user_id: String!): likes

  # fetch data from the table: "notifications"
  notifications(
    # distinct select on columns
    distinct_on: [notifications_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notifications_order_by!]

    # filter the rows returned
    where: notifications_bool_exp
  ): [notifications!]!

  # fetch aggregated fields from the table: "notifications"
  notifications_aggregate(
    # distinct select on columns
    distinct_on: [notifications_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [notifications_order_by!]

    # filter the rows returned
    where: notifications_bool_exp
  ): notifications_aggregate!

  # fetch data from the table: "notifications" using primary key columns
  notifications_by_pk(id: Int!): notifications

  # execute function "unachievedachievements" which returns "achievement"
  unachievedachievements(
    # input parameters for function "unachievedachievements"
    args: unachievedachievements_args!

    # distinct select on columns
    distinct_on: [achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_order_by!]

    # filter the rows returned
    where: achievement_bool_exp
  ): [achievement!]!

  # execute function "unachievedachievements" and query aggregates on result of table type "achievement"
  unachievedachievements_aggregate(
    # input parameters for function "unachievedachievements"
    args: unachievedachievements_args!

    # distinct select on columns
    distinct_on: [achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [achievement_order_by!]

    # filter the rows returned
    where: achievement_bool_exp
  ): achievement_aggregate!

  # fetch data from the table: "users" using primary key columns
  user(id: String!): users

  # fetch data from the table: "user_achievement"
  user_achievement(
    # distinct select on columns
    distinct_on: [user_achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_achievement_order_by!]

    # filter the rows returned
    where: user_achievement_bool_exp
  ): [user_achievement!]!

  # fetch aggregated fields from the table: "user_achievement"
  user_achievement_aggregate(
    # distinct select on columns
    distinct_on: [user_achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_achievement_order_by!]

    # filter the rows returned
    where: user_achievement_bool_exp
  ): user_achievement_aggregate!

  # fetch data from the table: "user_achievement" using primary key columns
  user_achievement_by_pk(achievement_id: Int!, user_id: String!): user_achievement

  # fetch data from the table: "users"
  users(
    # distinct select on columns
    distinct_on: [users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [users_order_by!]

    # filter the rows returned
    where: users_bool_exp
  ): [users!]!

  # fetch aggregated fields from the table: "users"
  users_aggregate(
    # distinct select on columns
    distinct_on: [users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [users_order_by!]

    # filter the rows returned
    where: users_bool_exp
  ): users_aggregate!
}

scalar timestamp

# expression to compare columns of type timestamp. All fields are combined with logical 'AND'.
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

input unachievedachievements_args {
  uid: String
}

# columns and relationships of "user_achievement"
type user_achievement {
  # An object relationship
  achievement: achievement!
  achievement_id: Int!
  created_at: timestamptz!

  # An object relationship
  user: users!
  user_id: String!
}

# aggregated selection of "user_achievement"
type user_achievement_aggregate {
  aggregate: user_achievement_aggregate_fields
  nodes: [user_achievement!]!
}

# aggregate fields of "user_achievement"
type user_achievement_aggregate_fields {
  avg: user_achievement_avg_fields
  count(columns: [user_achievement_select_column!], distinct: Boolean): Int
  max: user_achievement_max_fields
  min: user_achievement_min_fields
  stddev: user_achievement_stddev_fields
  stddev_pop: user_achievement_stddev_pop_fields
  stddev_samp: user_achievement_stddev_samp_fields
  sum: user_achievement_sum_fields
  var_pop: user_achievement_var_pop_fields
  var_samp: user_achievement_var_samp_fields
  variance: user_achievement_variance_fields
}

# order by aggregate values of table "user_achievement"
input user_achievement_aggregate_order_by {
  avg: user_achievement_avg_order_by
  count: order_by
  max: user_achievement_max_order_by
  min: user_achievement_min_order_by
  stddev: user_achievement_stddev_order_by
  stddev_pop: user_achievement_stddev_pop_order_by
  stddev_samp: user_achievement_stddev_samp_order_by
  sum: user_achievement_sum_order_by
  var_pop: user_achievement_var_pop_order_by
  var_samp: user_achievement_var_samp_order_by
  variance: user_achievement_variance_order_by
}

# input type for inserting array relation for remote table "user_achievement"
input user_achievement_arr_rel_insert_input {
  data: [user_achievement_insert_input!]!
  on_conflict: user_achievement_on_conflict
}

# aggregate avg on columns
type user_achievement_avg_fields {
  achievement_id: Float
}

# order by avg() on columns of table "user_achievement"
input user_achievement_avg_order_by {
  achievement_id: order_by
}

# Boolean expression to filter rows from the table "user_achievement". All fields are combined with a logical 'AND'.
input user_achievement_bool_exp {
  _and: [user_achievement_bool_exp]
  _not: user_achievement_bool_exp
  _or: [user_achievement_bool_exp]
  achievement: achievement_bool_exp
  achievement_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: String_comparison_exp
}

# unique or primary key constraints on table "user_achievement"
enum user_achievement_constraint {
  # unique or primary key constraint
  user_achievement_pkey
}

# input type for incrementing integer column in table "user_achievement"
input user_achievement_inc_input {
  achievement_id: Int
}

# input type for inserting data into table "user_achievement"
input user_achievement_insert_input {
  achievement: achievement_obj_rel_insert_input
  achievement_id: Int
  created_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: String
}

# aggregate max on columns
type user_achievement_max_fields {
  achievement_id: Int
  created_at: timestamptz
  user_id: String
}

# order by max() on columns of table "user_achievement"
input user_achievement_max_order_by {
  achievement_id: order_by
  created_at: order_by
  user_id: order_by
}

# aggregate min on columns
type user_achievement_min_fields {
  achievement_id: Int
  created_at: timestamptz
  user_id: String
}

# order by min() on columns of table "user_achievement"
input user_achievement_min_order_by {
  achievement_id: order_by
  created_at: order_by
  user_id: order_by
}

# response of any mutation on the table "user_achievement"
type user_achievement_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [user_achievement!]!
}

# input type for inserting object relation for remote table "user_achievement"
input user_achievement_obj_rel_insert_input {
  data: user_achievement_insert_input!
  on_conflict: user_achievement_on_conflict
}

# on conflict condition type for table "user_achievement"
input user_achievement_on_conflict {
  constraint: user_achievement_constraint!
  update_columns: [user_achievement_update_column!]!
  where: user_achievement_bool_exp
}

# ordering options when selecting data from "user_achievement"
input user_achievement_order_by {
  achievement: achievement_order_by
  achievement_id: order_by
  created_at: order_by
  user: users_order_by
  user_id: order_by
}

# primary key columns input for table: "user_achievement"
input user_achievement_pk_columns_input {
  achievement_id: Int!
  user_id: String!
}

# select columns of table "user_achievement"
enum user_achievement_select_column {
  # column name
  achievement_id

  # column name
  created_at

  # column name
  user_id
}

# input type for updating data in table "user_achievement"
input user_achievement_set_input {
  achievement_id: Int
  created_at: timestamptz
  user_id: String
}

# aggregate stddev on columns
type user_achievement_stddev_fields {
  achievement_id: Float
}

# order by stddev() on columns of table "user_achievement"
input user_achievement_stddev_order_by {
  achievement_id: order_by
}

# aggregate stddev_pop on columns
type user_achievement_stddev_pop_fields {
  achievement_id: Float
}

# order by stddev_pop() on columns of table "user_achievement"
input user_achievement_stddev_pop_order_by {
  achievement_id: order_by
}

# aggregate stddev_samp on columns
type user_achievement_stddev_samp_fields {
  achievement_id: Float
}

# order by stddev_samp() on columns of table "user_achievement"
input user_achievement_stddev_samp_order_by {
  achievement_id: order_by
}

# aggregate sum on columns
type user_achievement_sum_fields {
  achievement_id: Int
}

# order by sum() on columns of table "user_achievement"
input user_achievement_sum_order_by {
  achievement_id: order_by
}

# update columns of table "user_achievement"
enum user_achievement_update_column {
  # column name
  achievement_id

  # column name
  created_at

  # column name
  user_id
}

# aggregate var_pop on columns
type user_achievement_var_pop_fields {
  achievement_id: Float
}

# order by var_pop() on columns of table "user_achievement"
input user_achievement_var_pop_order_by {
  achievement_id: order_by
}

# aggregate var_samp on columns
type user_achievement_var_samp_fields {
  achievement_id: Float
}

# order by var_samp() on columns of table "user_achievement"
input user_achievement_var_samp_order_by {
  achievement_id: order_by
}

# aggregate variance on columns
type user_achievement_variance_fields {
  achievement_id: Float
}

# order by variance() on columns of table "user_achievement"
input user_achievement_variance_order_by {
  achievement_id: order_by
}

# columns and relationships of "users"
type users {
  # An array relationship
  activities(
    # distinct select on columns
    distinct_on: [activities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [activities_order_by!]

    # filter the rows returned
    where: activities_bool_exp
  ): [activities!]!

  # An aggregated array relationship
  activities_aggregate(
    # distinct select on columns
    distinct_on: [activities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [activities_order_by!]

    # filter the rows returned
    where: activities_bool_exp
  ): activities_aggregate!
  bio: String

  # An array relationship
  challenge_participants(
    # distinct select on columns
    distinct_on: [challenge_participant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_order_by!]

    # filter the rows returned
    where: challenge_participant_bool_exp
  ): [challenge_participant!]!

  # An aggregated array relationship
  challenge_participants_aggregate(
    # distinct select on columns
    distinct_on: [challenge_participant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_participant_order_by!]

    # filter the rows returned
    where: challenge_participant_bool_exp
  ): challenge_participant_aggregate!

  # An array relationship
  challenges_won(
    # distinct select on columns
    distinct_on: [challenge_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_order_by!]

    # filter the rows returned
    where: challenge_bool_exp
  ): [challenge!]!

  # An aggregated array relationship
  challenges_won_aggregate(
    # distinct select on columns
    distinct_on: [challenge_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [challenge_order_by!]

    # filter the rows returned
    where: challenge_bool_exp
  ): challenge_aggregate!
  created_at: timestamptz
  email: String!

  # An array relationship
  followers(
    # distinct select on columns
    distinct_on: [followings_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [followings_order_by!]

    # filter the rows returned
    where: followings_bool_exp
  ): [followings!]!

  # An aggregated array relationship
  followers_aggregate(
    # distinct select on columns
    distinct_on: [followings_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [followings_order_by!]

    # filter the rows returned
    where: followings_bool_exp
  ): followings_aggregate!

  # An array relationship
  following(
    # distinct select on columns
    distinct_on: [followings_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [followings_order_by!]

    # filter the rows returned
    where: followings_bool_exp
  ): [followings!]!

  # An aggregated array relationship
  following_aggregate(
    # distinct select on columns
    distinct_on: [followings_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [followings_order_by!]

    # filter the rows returned
    where: followings_bool_exp
  ): followings_aggregate!
  id: String!
  name: String!
  picture: String

  # A computed field, executes function "totalscore"
  totalScore: bigint
  updated_at: timestamptz

  # An array relationship
  user_achievement(
    # distinct select on columns
    distinct_on: [user_achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_achievement_order_by!]

    # filter the rows returned
    where: user_achievement_bool_exp
  ): [user_achievement!]!

  # An aggregated array relationship
  user_achievement_aggregate(
    # distinct select on columns
    distinct_on: [user_achievement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [user_achievement_order_by!]

    # filter the rows returned
    where: user_achievement_bool_exp
  ): user_achievement_aggregate!
}

# aggregated selection of "users"
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

# aggregate fields of "users"
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int
  max: users_max_fields
  min: users_min_fields
}

# order by aggregate values of table "users"
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

# input type for inserting array relation for remote table "users"
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  on_conflict: users_on_conflict
}

# Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
input users_bool_exp {
  _and: [users_bool_exp]
  _not: users_bool_exp
  _or: [users_bool_exp]
  activities: activities_bool_exp
  bio: String_comparison_exp
  challenge_participants: challenge_participant_bool_exp
  challenges_won: challenge_bool_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  followers: followings_bool_exp
  following: followings_bool_exp
  id: String_comparison_exp
  name: String_comparison_exp
  picture: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_achievement: user_achievement_bool_exp
}

# unique or primary key constraints on table "users"
enum users_constraint {
  # unique or primary key constraint
  Users_email_key

  # unique or primary key constraint
  Users_id_key

  # unique or primary key constraint
  Users_pkey
}

# input type for inserting data into table "users"
input users_insert_input {
  activities: activities_arr_rel_insert_input
  bio: String
  challenge_participants: challenge_participant_arr_rel_insert_input
  challenges_won: challenge_arr_rel_insert_input
  created_at: timestamptz
  email: String
  followers: followings_arr_rel_insert_input
  following: followings_arr_rel_insert_input
  id: String
  name: String
  picture: String
  updated_at: timestamptz
  user_achievement: user_achievement_arr_rel_insert_input
}

# aggregate max on columns
type users_max_fields {
  bio: String
  created_at: timestamptz
  email: String
  id: String
  name: String
  picture: String
  updated_at: timestamptz
}

# order by max() on columns of table "users"
input users_max_order_by {
  bio: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  picture: order_by
  updated_at: order_by
}

# aggregate min on columns
type users_min_fields {
  bio: String
  created_at: timestamptz
  email: String
  id: String
  name: String
  picture: String
  updated_at: timestamptz
}

# order by min() on columns of table "users"
input users_min_order_by {
  bio: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  picture: order_by
  updated_at: order_by
}

# response of any mutation on the table "users"
type users_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [users!]!
}

# input type for inserting object relation for remote table "users"
input users_obj_rel_insert_input {
  data: users_insert_input!
  on_conflict: users_on_conflict
}

# on conflict condition type for table "users"
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

# ordering options when selecting data from "users"
input users_order_by {
  activities_aggregate: activities_aggregate_order_by
  bio: order_by
  challenge_participants_aggregate: challenge_participant_aggregate_order_by
  challenges_won_aggregate: challenge_aggregate_order_by
  created_at: order_by
  email: order_by
  followers_aggregate: followings_aggregate_order_by
  following_aggregate: followings_aggregate_order_by
  id: order_by
  name: order_by
  picture: order_by
  updated_at: order_by
  user_achievement_aggregate: user_achievement_aggregate_order_by
}

# primary key columns input for table: "users"
input users_pk_columns_input {
  id: String!
}

# select columns of table "users"
enum users_select_column {
  # column name
  bio

  # column name
  created_at

  # column name
  email

  # column name
  id

  # column name
  name

  # column name
  picture

  # column name
  updated_at
}

# input type for updating data in table "users"
input users_set_input {
  bio: String
  created_at: timestamptz
  email: String
  id: String
  name: String
  picture: String
  updated_at: timestamptz
}

# update columns of table "users"
enum users_update_column {
  # column name
  bio

  # column name
  created_at

  # column name
  email

  # column name
  id

  # column name
  name

  # column name
  picture

  # column name
  updated_at
}

